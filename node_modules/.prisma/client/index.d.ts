
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model USER_ACCOUNT
 * 
 */
export type USER_ACCOUNT = {
  US_ID: bigint
  US_ACCOUNT: string
  US_PASSWORD: string
  TOKEN: string | null
}

/**
 * Model USER_INFO
 * 
 */
export type USER_INFO = {
  US_ID: bigint
  US_NAME: string | null
  US_MAIL: string | null
  US_PHONE: string | null
  US_BIRTH: Date | null
  US_GENDER: string | null
  US_ADDRESS: string | null
}

/**
 * Model PROJECT_ACCESSIBILITY
 * 
 */
export type PROJECT_ACCESSIBILITY = {
  MEM_POS: bigint
  DEL_PJ: string | null
  EDIT_MEM_POS: string | null
  EDIT_MEM: string | null
  EDIT_STATUS: string | null
  CREATE_ANNOUNC_MNT: string | null
}

/**
 * Model PROJECT_INFO
 * 
 */
export type PROJECT_INFO = {
  PJ_ID: bigint
  PJ_NAME: string | null
  PJ_CREATEDAY: Date | null
  PJ_DEADLINE: Date | null
  PJ_STATUS: string | null
  PJ_ADMIN: bigint | null
  PJ_OWNER: string | null
}

/**
 * Model PROJECT_MEMBER
 * 
 */
export type PROJECT_MEMBER = {
  PJ_ID: bigint
  MEM_ID: bigint
  MEM_POS: bigint | null
}

/**
 * Model TASK_ACCESSIBILITY
 * 
 */
export type TASK_ACCESSIBILITY = {
  MEM_POS: bigint
  EDIT_MEM: string | null
  ADD_TASK: string | null
  DEL_TASK: string | null
  EDIT_NAME: string | null
  EDIT_DEADLINE: string | null
  EDIT_STATUS: string | null
  EDIT_DESCRIPTION: string | null
}

/**
 * Model TASK_INFO
 * 
 */
export type TASK_INFO = {
  PJ_ID: bigint
  TASK_ID: bigint
  TASK_STATUS: string | null
  TASK_NAME: string | null
  TASK_DESCRIPTON: string | null
  TASK_CREATEDAY: Date | null
  TASK_DEADLINE: Date | null
  TASK_CREATOR: bigint | null
}

/**
 * Model TASK_RESPONDSIPLE
 * 
 */
export type TASK_RESPONDSIPLE = {
  PJ_ID: bigint
  TASK_ID: bigint
  MEM_ID: bigint
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more USER_ACCOUNTS
 * const uSER_ACCOUNTS = await prisma.uSER_ACCOUNT.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more USER_ACCOUNTS
   * const uSER_ACCOUNTS = await prisma.uSER_ACCOUNT.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.uSER_ACCOUNT`: Exposes CRUD operations for the **USER_ACCOUNT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more USER_ACCOUNTS
    * const uSER_ACCOUNTS = await prisma.uSER_ACCOUNT.findMany()
    * ```
    */
  get uSER_ACCOUNT(): Prisma.USER_ACCOUNTDelegate<GlobalReject>;

  /**
   * `prisma.uSER_INFO`: Exposes CRUD operations for the **USER_INFO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more USER_INFOS
    * const uSER_INFOS = await prisma.uSER_INFO.findMany()
    * ```
    */
  get uSER_INFO(): Prisma.USER_INFODelegate<GlobalReject>;

  /**
   * `prisma.pROJECT_ACCESSIBILITY`: Exposes CRUD operations for the **PROJECT_ACCESSIBILITY** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PROJECT_ACCESSIBILITIES
    * const pROJECT_ACCESSIBILITIES = await prisma.pROJECT_ACCESSIBILITY.findMany()
    * ```
    */
  get pROJECT_ACCESSIBILITY(): Prisma.PROJECT_ACCESSIBILITYDelegate<GlobalReject>;

  /**
   * `prisma.pROJECT_INFO`: Exposes CRUD operations for the **PROJECT_INFO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PROJECT_INFOS
    * const pROJECT_INFOS = await prisma.pROJECT_INFO.findMany()
    * ```
    */
  get pROJECT_INFO(): Prisma.PROJECT_INFODelegate<GlobalReject>;

  /**
   * `prisma.pROJECT_MEMBER`: Exposes CRUD operations for the **PROJECT_MEMBER** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PROJECT_MEMBERS
    * const pROJECT_MEMBERS = await prisma.pROJECT_MEMBER.findMany()
    * ```
    */
  get pROJECT_MEMBER(): Prisma.PROJECT_MEMBERDelegate<GlobalReject>;

  /**
   * `prisma.tASK_ACCESSIBILITY`: Exposes CRUD operations for the **TASK_ACCESSIBILITY** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TASK_ACCESSIBILITIES
    * const tASK_ACCESSIBILITIES = await prisma.tASK_ACCESSIBILITY.findMany()
    * ```
    */
  get tASK_ACCESSIBILITY(): Prisma.TASK_ACCESSIBILITYDelegate<GlobalReject>;

  /**
   * `prisma.tASK_INFO`: Exposes CRUD operations for the **TASK_INFO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TASK_INFOS
    * const tASK_INFOS = await prisma.tASK_INFO.findMany()
    * ```
    */
  get tASK_INFO(): Prisma.TASK_INFODelegate<GlobalReject>;

  /**
   * `prisma.tASK_RESPONDSIPLE`: Exposes CRUD operations for the **TASK_RESPONDSIPLE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TASK_RESPONDSIPLES
    * const tASK_RESPONDSIPLES = await prisma.tASK_RESPONDSIPLE.findMany()
    * ```
    */
  get tASK_RESPONDSIPLE(): Prisma.TASK_RESPONDSIPLEDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.1.0
   * Query Engine version: da41d2bb3406da22087b849f0e911199ba4fbf11
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    USER_ACCOUNT: 'USER_ACCOUNT',
    USER_INFO: 'USER_INFO',
    PROJECT_ACCESSIBILITY: 'PROJECT_ACCESSIBILITY',
    PROJECT_INFO: 'PROJECT_INFO',
    PROJECT_MEMBER: 'PROJECT_MEMBER',
    TASK_ACCESSIBILITY: 'TASK_ACCESSIBILITY',
    TASK_INFO: 'TASK_INFO',
    TASK_RESPONDSIPLE: 'TASK_RESPONDSIPLE'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type USER_INFOCountOutputType
   */


  export type USER_INFOCountOutputType = {
    PROJECT_MEMBER: number
  }

  export type USER_INFOCountOutputTypeSelect = {
    PROJECT_MEMBER?: boolean
  }

  export type USER_INFOCountOutputTypeGetPayload<
    S extends boolean | null | undefined | USER_INFOCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? USER_INFOCountOutputType
    : S extends undefined
    ? never
    : S extends USER_INFOCountOutputTypeArgs
    ?'include' extends U
    ? USER_INFOCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof USER_INFOCountOutputType ? USER_INFOCountOutputType[P] : never
  } 
    : USER_INFOCountOutputType
  : USER_INFOCountOutputType




  // Custom InputTypes

  /**
   * USER_INFOCountOutputType without action
   */
  export type USER_INFOCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the USER_INFOCountOutputType
     * 
    **/
    select?: USER_INFOCountOutputTypeSelect | null
  }



  /**
   * Count Type PROJECT_ACCESSIBILITYCountOutputType
   */


  export type PROJECT_ACCESSIBILITYCountOutputType = {
    PROJECT_MEMBER: number
  }

  export type PROJECT_ACCESSIBILITYCountOutputTypeSelect = {
    PROJECT_MEMBER?: boolean
  }

  export type PROJECT_ACCESSIBILITYCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PROJECT_ACCESSIBILITYCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PROJECT_ACCESSIBILITYCountOutputType
    : S extends undefined
    ? never
    : S extends PROJECT_ACCESSIBILITYCountOutputTypeArgs
    ?'include' extends U
    ? PROJECT_ACCESSIBILITYCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PROJECT_ACCESSIBILITYCountOutputType ? PROJECT_ACCESSIBILITYCountOutputType[P] : never
  } 
    : PROJECT_ACCESSIBILITYCountOutputType
  : PROJECT_ACCESSIBILITYCountOutputType




  // Custom InputTypes

  /**
   * PROJECT_ACCESSIBILITYCountOutputType without action
   */
  export type PROJECT_ACCESSIBILITYCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITYCountOutputType
     * 
    **/
    select?: PROJECT_ACCESSIBILITYCountOutputTypeSelect | null
  }



  /**
   * Count Type PROJECT_INFOCountOutputType
   */


  export type PROJECT_INFOCountOutputType = {
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: number
    TASK_INFO: number
  }

  export type PROJECT_INFOCountOutputTypeSelect = {
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: boolean
    TASK_INFO?: boolean
  }

  export type PROJECT_INFOCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PROJECT_INFOCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PROJECT_INFOCountOutputType
    : S extends undefined
    ? never
    : S extends PROJECT_INFOCountOutputTypeArgs
    ?'include' extends U
    ? PROJECT_INFOCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PROJECT_INFOCountOutputType ? PROJECT_INFOCountOutputType[P] : never
  } 
    : PROJECT_INFOCountOutputType
  : PROJECT_INFOCountOutputType




  // Custom InputTypes

  /**
   * PROJECT_INFOCountOutputType without action
   */
  export type PROJECT_INFOCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFOCountOutputType
     * 
    **/
    select?: PROJECT_INFOCountOutputTypeSelect | null
  }



  /**
   * Count Type PROJECT_MEMBERCountOutputType
   */


  export type PROJECT_MEMBERCountOutputType = {
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER: number
    TASK_INFO: number
    TASK_RESPONDSIPLE: number
  }

  export type PROJECT_MEMBERCountOutputTypeSelect = {
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: boolean
    TASK_INFO?: boolean
    TASK_RESPONDSIPLE?: boolean
  }

  export type PROJECT_MEMBERCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PROJECT_MEMBERCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PROJECT_MEMBERCountOutputType
    : S extends undefined
    ? never
    : S extends PROJECT_MEMBERCountOutputTypeArgs
    ?'include' extends U
    ? PROJECT_MEMBERCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PROJECT_MEMBERCountOutputType ? PROJECT_MEMBERCountOutputType[P] : never
  } 
    : PROJECT_MEMBERCountOutputType
  : PROJECT_MEMBERCountOutputType




  // Custom InputTypes

  /**
   * PROJECT_MEMBERCountOutputType without action
   */
  export type PROJECT_MEMBERCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBERCountOutputType
     * 
    **/
    select?: PROJECT_MEMBERCountOutputTypeSelect | null
  }



  /**
   * Count Type TASK_ACCESSIBILITYCountOutputType
   */


  export type TASK_ACCESSIBILITYCountOutputType = {
    PROJECT_MEMBER: number
  }

  export type TASK_ACCESSIBILITYCountOutputTypeSelect = {
    PROJECT_MEMBER?: boolean
  }

  export type TASK_ACCESSIBILITYCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TASK_ACCESSIBILITYCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TASK_ACCESSIBILITYCountOutputType
    : S extends undefined
    ? never
    : S extends TASK_ACCESSIBILITYCountOutputTypeArgs
    ?'include' extends U
    ? TASK_ACCESSIBILITYCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TASK_ACCESSIBILITYCountOutputType ? TASK_ACCESSIBILITYCountOutputType[P] : never
  } 
    : TASK_ACCESSIBILITYCountOutputType
  : TASK_ACCESSIBILITYCountOutputType




  // Custom InputTypes

  /**
   * TASK_ACCESSIBILITYCountOutputType without action
   */
  export type TASK_ACCESSIBILITYCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITYCountOutputType
     * 
    **/
    select?: TASK_ACCESSIBILITYCountOutputTypeSelect | null
  }



  /**
   * Count Type TASK_INFOCountOutputType
   */


  export type TASK_INFOCountOutputType = {
    TASK_RESPONDSIPLE: number
  }

  export type TASK_INFOCountOutputTypeSelect = {
    TASK_RESPONDSIPLE?: boolean
  }

  export type TASK_INFOCountOutputTypeGetPayload<
    S extends boolean | null | undefined | TASK_INFOCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? TASK_INFOCountOutputType
    : S extends undefined
    ? never
    : S extends TASK_INFOCountOutputTypeArgs
    ?'include' extends U
    ? TASK_INFOCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TASK_INFOCountOutputType ? TASK_INFOCountOutputType[P] : never
  } 
    : TASK_INFOCountOutputType
  : TASK_INFOCountOutputType




  // Custom InputTypes

  /**
   * TASK_INFOCountOutputType without action
   */
  export type TASK_INFOCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFOCountOutputType
     * 
    **/
    select?: TASK_INFOCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model USER_ACCOUNT
   */


  export type AggregateUSER_ACCOUNT = {
    _count: USER_ACCOUNTCountAggregateOutputType | null
    _avg: USER_ACCOUNTAvgAggregateOutputType | null
    _sum: USER_ACCOUNTSumAggregateOutputType | null
    _min: USER_ACCOUNTMinAggregateOutputType | null
    _max: USER_ACCOUNTMaxAggregateOutputType | null
  }

  export type USER_ACCOUNTAvgAggregateOutputType = {
    US_ID: number | null
  }

  export type USER_ACCOUNTSumAggregateOutputType = {
    US_ID: bigint | null
  }

  export type USER_ACCOUNTMinAggregateOutputType = {
    US_ID: bigint | null
    US_ACCOUNT: string | null
    US_PASSWORD: string | null
    TOKEN: string | null
  }

  export type USER_ACCOUNTMaxAggregateOutputType = {
    US_ID: bigint | null
    US_ACCOUNT: string | null
    US_PASSWORD: string | null
    TOKEN: string | null
  }

  export type USER_ACCOUNTCountAggregateOutputType = {
    US_ID: number
    US_ACCOUNT: number
    US_PASSWORD: number
    TOKEN: number
    _all: number
  }


  export type USER_ACCOUNTAvgAggregateInputType = {
    US_ID?: true
  }

  export type USER_ACCOUNTSumAggregateInputType = {
    US_ID?: true
  }

  export type USER_ACCOUNTMinAggregateInputType = {
    US_ID?: true
    US_ACCOUNT?: true
    US_PASSWORD?: true
    TOKEN?: true
  }

  export type USER_ACCOUNTMaxAggregateInputType = {
    US_ID?: true
    US_ACCOUNT?: true
    US_PASSWORD?: true
    TOKEN?: true
  }

  export type USER_ACCOUNTCountAggregateInputType = {
    US_ID?: true
    US_ACCOUNT?: true
    US_PASSWORD?: true
    TOKEN?: true
    _all?: true
  }

  export type USER_ACCOUNTAggregateArgs = {
    /**
     * Filter which USER_ACCOUNT to aggregate.
     * 
    **/
    where?: USER_ACCOUNTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_ACCOUNTS to fetch.
     * 
    **/
    orderBy?: Enumerable<USER_ACCOUNTOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: USER_ACCOUNTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_ACCOUNTS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_ACCOUNTS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned USER_ACCOUNTS
    **/
    _count?: true | USER_ACCOUNTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: USER_ACCOUNTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: USER_ACCOUNTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: USER_ACCOUNTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: USER_ACCOUNTMaxAggregateInputType
  }

  export type GetUSER_ACCOUNTAggregateType<T extends USER_ACCOUNTAggregateArgs> = {
        [P in keyof T & keyof AggregateUSER_ACCOUNT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUSER_ACCOUNT[P]>
      : GetScalarType<T[P], AggregateUSER_ACCOUNT[P]>
  }




  export type USER_ACCOUNTGroupByArgs = {
    where?: USER_ACCOUNTWhereInput
    orderBy?: Enumerable<USER_ACCOUNTOrderByWithAggregationInput>
    by: Array<USER_ACCOUNTScalarFieldEnum>
    having?: USER_ACCOUNTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: USER_ACCOUNTCountAggregateInputType | true
    _avg?: USER_ACCOUNTAvgAggregateInputType
    _sum?: USER_ACCOUNTSumAggregateInputType
    _min?: USER_ACCOUNTMinAggregateInputType
    _max?: USER_ACCOUNTMaxAggregateInputType
  }


  export type USER_ACCOUNTGroupByOutputType = {
    US_ID: bigint
    US_ACCOUNT: string
    US_PASSWORD: string
    TOKEN: string | null
    _count: USER_ACCOUNTCountAggregateOutputType | null
    _avg: USER_ACCOUNTAvgAggregateOutputType | null
    _sum: USER_ACCOUNTSumAggregateOutputType | null
    _min: USER_ACCOUNTMinAggregateOutputType | null
    _max: USER_ACCOUNTMaxAggregateOutputType | null
  }

  type GetUSER_ACCOUNTGroupByPayload<T extends USER_ACCOUNTGroupByArgs> = PrismaPromise<
    Array<
      PickArray<USER_ACCOUNTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof USER_ACCOUNTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], USER_ACCOUNTGroupByOutputType[P]>
            : GetScalarType<T[P], USER_ACCOUNTGroupByOutputType[P]>
        }
      >
    >


  export type USER_ACCOUNTSelect = {
    US_ID?: boolean
    US_ACCOUNT?: boolean
    US_PASSWORD?: boolean
    TOKEN?: boolean
    USER_INFO?: boolean | USER_INFOArgs
  }

  export type USER_ACCOUNTInclude = {
    USER_INFO?: boolean | USER_INFOArgs
  }

  export type USER_ACCOUNTGetPayload<
    S extends boolean | null | undefined | USER_ACCOUNTArgs,
    U = keyof S
      > = S extends true
        ? USER_ACCOUNT
    : S extends undefined
    ? never
    : S extends USER_ACCOUNTArgs | USER_ACCOUNTFindManyArgs
    ?'include' extends U
    ? USER_ACCOUNT  & {
    [P in TrueKeys<S['include']>]:
        P extends 'USER_INFO' ? USER_INFOGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'USER_INFO' ? USER_INFOGetPayload<S['select'][P]> | null :  P extends keyof USER_ACCOUNT ? USER_ACCOUNT[P] : never
  } 
    : USER_ACCOUNT
  : USER_ACCOUNT


  type USER_ACCOUNTCountArgs = Merge<
    Omit<USER_ACCOUNTFindManyArgs, 'select' | 'include'> & {
      select?: USER_ACCOUNTCountAggregateInputType | true
    }
  >

  export interface USER_ACCOUNTDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one USER_ACCOUNT that matches the filter.
     * @param {USER_ACCOUNTFindUniqueArgs} args - Arguments to find a USER_ACCOUNT
     * @example
     * // Get one USER_ACCOUNT
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends USER_ACCOUNTFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, USER_ACCOUNTFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'USER_ACCOUNT'> extends True ? CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>> : CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT | null >, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T> | null >>

    /**
     * Find the first USER_ACCOUNT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTFindFirstArgs} args - Arguments to find a USER_ACCOUNT
     * @example
     * // Get one USER_ACCOUNT
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends USER_ACCOUNTFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, USER_ACCOUNTFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'USER_ACCOUNT'> extends True ? CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>> : CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT | null >, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T> | null >>

    /**
     * Find zero or more USER_ACCOUNTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all USER_ACCOUNTS
     * const uSER_ACCOUNTS = await prisma.uSER_ACCOUNT.findMany()
     * 
     * // Get first 10 USER_ACCOUNTS
     * const uSER_ACCOUNTS = await prisma.uSER_ACCOUNT.findMany({ take: 10 })
     * 
     * // Only select the `US_ID`
     * const uSER_ACCOUNTWithUS_IDOnly = await prisma.uSER_ACCOUNT.findMany({ select: { US_ID: true } })
     * 
    **/
    findMany<T extends USER_ACCOUNTFindManyArgs>(
      args?: SelectSubset<T, USER_ACCOUNTFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<USER_ACCOUNT>>, PrismaPromise<Array<USER_ACCOUNTGetPayload<T>>>>

    /**
     * Create a USER_ACCOUNT.
     * @param {USER_ACCOUNTCreateArgs} args - Arguments to create a USER_ACCOUNT.
     * @example
     * // Create one USER_ACCOUNT
     * const USER_ACCOUNT = await prisma.uSER_ACCOUNT.create({
     *   data: {
     *     // ... data to create a USER_ACCOUNT
     *   }
     * })
     * 
    **/
    create<T extends USER_ACCOUNTCreateArgs>(
      args: SelectSubset<T, USER_ACCOUNTCreateArgs>
    ): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>>

    /**
     * Create many USER_ACCOUNTS.
     *     @param {USER_ACCOUNTCreateManyArgs} args - Arguments to create many USER_ACCOUNTS.
     *     @example
     *     // Create many USER_ACCOUNTS
     *     const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends USER_ACCOUNTCreateManyArgs>(
      args?: SelectSubset<T, USER_ACCOUNTCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a USER_ACCOUNT.
     * @param {USER_ACCOUNTDeleteArgs} args - Arguments to delete one USER_ACCOUNT.
     * @example
     * // Delete one USER_ACCOUNT
     * const USER_ACCOUNT = await prisma.uSER_ACCOUNT.delete({
     *   where: {
     *     // ... filter to delete one USER_ACCOUNT
     *   }
     * })
     * 
    **/
    delete<T extends USER_ACCOUNTDeleteArgs>(
      args: SelectSubset<T, USER_ACCOUNTDeleteArgs>
    ): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>>

    /**
     * Update one USER_ACCOUNT.
     * @param {USER_ACCOUNTUpdateArgs} args - Arguments to update one USER_ACCOUNT.
     * @example
     * // Update one USER_ACCOUNT
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends USER_ACCOUNTUpdateArgs>(
      args: SelectSubset<T, USER_ACCOUNTUpdateArgs>
    ): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>>

    /**
     * Delete zero or more USER_ACCOUNTS.
     * @param {USER_ACCOUNTDeleteManyArgs} args - Arguments to filter USER_ACCOUNTS to delete.
     * @example
     * // Delete a few USER_ACCOUNTS
     * const { count } = await prisma.uSER_ACCOUNT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends USER_ACCOUNTDeleteManyArgs>(
      args?: SelectSubset<T, USER_ACCOUNTDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more USER_ACCOUNTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many USER_ACCOUNTS
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends USER_ACCOUNTUpdateManyArgs>(
      args: SelectSubset<T, USER_ACCOUNTUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one USER_ACCOUNT.
     * @param {USER_ACCOUNTUpsertArgs} args - Arguments to update or create a USER_ACCOUNT.
     * @example
     * // Update or create a USER_ACCOUNT
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.upsert({
     *   create: {
     *     // ... data to create a USER_ACCOUNT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the USER_ACCOUNT we want to update
     *   }
     * })
    **/
    upsert<T extends USER_ACCOUNTUpsertArgs>(
      args: SelectSubset<T, USER_ACCOUNTUpsertArgs>
    ): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>>

    /**
     * Find one USER_ACCOUNT that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {USER_ACCOUNTFindUniqueOrThrowArgs} args - Arguments to find a USER_ACCOUNT
     * @example
     * // Get one USER_ACCOUNT
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends USER_ACCOUNTFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, USER_ACCOUNTFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>>

    /**
     * Find the first USER_ACCOUNT that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTFindFirstOrThrowArgs} args - Arguments to find a USER_ACCOUNT
     * @example
     * // Get one USER_ACCOUNT
     * const uSER_ACCOUNT = await prisma.uSER_ACCOUNT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends USER_ACCOUNTFindFirstOrThrowArgs>(
      args?: SelectSubset<T, USER_ACCOUNTFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT>, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T>>>

    /**
     * Count the number of USER_ACCOUNTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTCountArgs} args - Arguments to filter USER_ACCOUNTS to count.
     * @example
     * // Count the number of USER_ACCOUNTS
     * const count = await prisma.uSER_ACCOUNT.count({
     *   where: {
     *     // ... the filter for the USER_ACCOUNTS we want to count
     *   }
     * })
    **/
    count<T extends USER_ACCOUNTCountArgs>(
      args?: Subset<T, USER_ACCOUNTCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], USER_ACCOUNTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a USER_ACCOUNT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends USER_ACCOUNTAggregateArgs>(args: Subset<T, USER_ACCOUNTAggregateArgs>): PrismaPromise<GetUSER_ACCOUNTAggregateType<T>>

    /**
     * Group by USER_ACCOUNT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_ACCOUNTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends USER_ACCOUNTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: USER_ACCOUNTGroupByArgs['orderBy'] }
        : { orderBy?: USER_ACCOUNTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, USER_ACCOUNTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUSER_ACCOUNTGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for USER_ACCOUNT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__USER_ACCOUNTClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    USER_INFO<T extends USER_INFOArgs = {}>(args?: Subset<T, USER_INFOArgs>): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO | null >, Prisma__USER_INFOClient<USER_INFOGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * USER_ACCOUNT base type for findUnique actions
   */
  export type USER_ACCOUNTFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * Filter, which USER_ACCOUNT to fetch.
     * 
    **/
    where: USER_ACCOUNTWhereUniqueInput
  }

  /**
   * USER_ACCOUNT: findUnique
   */
  export interface USER_ACCOUNTFindUniqueArgs extends USER_ACCOUNTFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * USER_ACCOUNT base type for findFirst actions
   */
  export type USER_ACCOUNTFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * Filter, which USER_ACCOUNT to fetch.
     * 
    **/
    where?: USER_ACCOUNTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_ACCOUNTS to fetch.
     * 
    **/
    orderBy?: Enumerable<USER_ACCOUNTOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USER_ACCOUNTS.
     * 
    **/
    cursor?: USER_ACCOUNTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_ACCOUNTS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_ACCOUNTS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USER_ACCOUNTS.
     * 
    **/
    distinct?: Enumerable<USER_ACCOUNTScalarFieldEnum>
  }

  /**
   * USER_ACCOUNT: findFirst
   */
  export interface USER_ACCOUNTFindFirstArgs extends USER_ACCOUNTFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * USER_ACCOUNT findMany
   */
  export type USER_ACCOUNTFindManyArgs = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * Filter, which USER_ACCOUNTS to fetch.
     * 
    **/
    where?: USER_ACCOUNTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_ACCOUNTS to fetch.
     * 
    **/
    orderBy?: Enumerable<USER_ACCOUNTOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing USER_ACCOUNTS.
     * 
    **/
    cursor?: USER_ACCOUNTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_ACCOUNTS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_ACCOUNTS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<USER_ACCOUNTScalarFieldEnum>
  }


  /**
   * USER_ACCOUNT create
   */
  export type USER_ACCOUNTCreateArgs = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * The data needed to create a USER_ACCOUNT.
     * 
    **/
    data: XOR<USER_ACCOUNTCreateInput, USER_ACCOUNTUncheckedCreateInput>
  }


  /**
   * USER_ACCOUNT createMany
   */
  export type USER_ACCOUNTCreateManyArgs = {
    /**
     * The data used to create many USER_ACCOUNTS.
     * 
    **/
    data: Enumerable<USER_ACCOUNTCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * USER_ACCOUNT update
   */
  export type USER_ACCOUNTUpdateArgs = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * The data needed to update a USER_ACCOUNT.
     * 
    **/
    data: XOR<USER_ACCOUNTUpdateInput, USER_ACCOUNTUncheckedUpdateInput>
    /**
     * Choose, which USER_ACCOUNT to update.
     * 
    **/
    where: USER_ACCOUNTWhereUniqueInput
  }


  /**
   * USER_ACCOUNT updateMany
   */
  export type USER_ACCOUNTUpdateManyArgs = {
    /**
     * The data used to update USER_ACCOUNTS.
     * 
    **/
    data: XOR<USER_ACCOUNTUpdateManyMutationInput, USER_ACCOUNTUncheckedUpdateManyInput>
    /**
     * Filter which USER_ACCOUNTS to update
     * 
    **/
    where?: USER_ACCOUNTWhereInput
  }


  /**
   * USER_ACCOUNT upsert
   */
  export type USER_ACCOUNTUpsertArgs = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * The filter to search for the USER_ACCOUNT to update in case it exists.
     * 
    **/
    where: USER_ACCOUNTWhereUniqueInput
    /**
     * In case the USER_ACCOUNT found by the `where` argument doesn't exist, create a new USER_ACCOUNT with this data.
     * 
    **/
    create: XOR<USER_ACCOUNTCreateInput, USER_ACCOUNTUncheckedCreateInput>
    /**
     * In case the USER_ACCOUNT was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<USER_ACCOUNTUpdateInput, USER_ACCOUNTUncheckedUpdateInput>
  }


  /**
   * USER_ACCOUNT delete
   */
  export type USER_ACCOUNTDeleteArgs = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
    /**
     * Filter which USER_ACCOUNT to delete.
     * 
    **/
    where: USER_ACCOUNTWhereUniqueInput
  }


  /**
   * USER_ACCOUNT deleteMany
   */
  export type USER_ACCOUNTDeleteManyArgs = {
    /**
     * Filter which USER_ACCOUNTS to delete
     * 
    **/
    where?: USER_ACCOUNTWhereInput
  }


  /**
   * USER_ACCOUNT: findUniqueOrThrow
   */
  export type USER_ACCOUNTFindUniqueOrThrowArgs = USER_ACCOUNTFindUniqueArgsBase
      

  /**
   * USER_ACCOUNT: findFirstOrThrow
   */
  export type USER_ACCOUNTFindFirstOrThrowArgs = USER_ACCOUNTFindFirstArgsBase
      

  /**
   * USER_ACCOUNT without action
   */
  export type USER_ACCOUNTArgs = {
    /**
     * Select specific fields to fetch from the USER_ACCOUNT
     * 
    **/
    select?: USER_ACCOUNTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_ACCOUNTInclude | null
  }



  /**
   * Model USER_INFO
   */


  export type AggregateUSER_INFO = {
    _count: USER_INFOCountAggregateOutputType | null
    _avg: USER_INFOAvgAggregateOutputType | null
    _sum: USER_INFOSumAggregateOutputType | null
    _min: USER_INFOMinAggregateOutputType | null
    _max: USER_INFOMaxAggregateOutputType | null
  }

  export type USER_INFOAvgAggregateOutputType = {
    US_ID: number | null
  }

  export type USER_INFOSumAggregateOutputType = {
    US_ID: bigint | null
  }

  export type USER_INFOMinAggregateOutputType = {
    US_ID: bigint | null
    US_NAME: string | null
    US_MAIL: string | null
    US_PHONE: string | null
    US_BIRTH: Date | null
    US_GENDER: string | null
    US_ADDRESS: string | null
  }

  export type USER_INFOMaxAggregateOutputType = {
    US_ID: bigint | null
    US_NAME: string | null
    US_MAIL: string | null
    US_PHONE: string | null
    US_BIRTH: Date | null
    US_GENDER: string | null
    US_ADDRESS: string | null
  }

  export type USER_INFOCountAggregateOutputType = {
    US_ID: number
    US_NAME: number
    US_MAIL: number
    US_PHONE: number
    US_BIRTH: number
    US_GENDER: number
    US_ADDRESS: number
    _all: number
  }


  export type USER_INFOAvgAggregateInputType = {
    US_ID?: true
  }

  export type USER_INFOSumAggregateInputType = {
    US_ID?: true
  }

  export type USER_INFOMinAggregateInputType = {
    US_ID?: true
    US_NAME?: true
    US_MAIL?: true
    US_PHONE?: true
    US_BIRTH?: true
    US_GENDER?: true
    US_ADDRESS?: true
  }

  export type USER_INFOMaxAggregateInputType = {
    US_ID?: true
    US_NAME?: true
    US_MAIL?: true
    US_PHONE?: true
    US_BIRTH?: true
    US_GENDER?: true
    US_ADDRESS?: true
  }

  export type USER_INFOCountAggregateInputType = {
    US_ID?: true
    US_NAME?: true
    US_MAIL?: true
    US_PHONE?: true
    US_BIRTH?: true
    US_GENDER?: true
    US_ADDRESS?: true
    _all?: true
  }

  export type USER_INFOAggregateArgs = {
    /**
     * Filter which USER_INFO to aggregate.
     * 
    **/
    where?: USER_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<USER_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: USER_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_INFOS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned USER_INFOS
    **/
    _count?: true | USER_INFOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: USER_INFOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: USER_INFOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: USER_INFOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: USER_INFOMaxAggregateInputType
  }

  export type GetUSER_INFOAggregateType<T extends USER_INFOAggregateArgs> = {
        [P in keyof T & keyof AggregateUSER_INFO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUSER_INFO[P]>
      : GetScalarType<T[P], AggregateUSER_INFO[P]>
  }




  export type USER_INFOGroupByArgs = {
    where?: USER_INFOWhereInput
    orderBy?: Enumerable<USER_INFOOrderByWithAggregationInput>
    by: Array<USER_INFOScalarFieldEnum>
    having?: USER_INFOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: USER_INFOCountAggregateInputType | true
    _avg?: USER_INFOAvgAggregateInputType
    _sum?: USER_INFOSumAggregateInputType
    _min?: USER_INFOMinAggregateInputType
    _max?: USER_INFOMaxAggregateInputType
  }


  export type USER_INFOGroupByOutputType = {
    US_ID: bigint
    US_NAME: string | null
    US_MAIL: string | null
    US_PHONE: string | null
    US_BIRTH: Date | null
    US_GENDER: string | null
    US_ADDRESS: string | null
    _count: USER_INFOCountAggregateOutputType | null
    _avg: USER_INFOAvgAggregateOutputType | null
    _sum: USER_INFOSumAggregateOutputType | null
    _min: USER_INFOMinAggregateOutputType | null
    _max: USER_INFOMaxAggregateOutputType | null
  }

  type GetUSER_INFOGroupByPayload<T extends USER_INFOGroupByArgs> = PrismaPromise<
    Array<
      PickArray<USER_INFOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof USER_INFOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], USER_INFOGroupByOutputType[P]>
            : GetScalarType<T[P], USER_INFOGroupByOutputType[P]>
        }
      >
    >


  export type USER_INFOSelect = {
    US_ID?: boolean
    US_NAME?: boolean
    US_MAIL?: boolean
    US_PHONE?: boolean
    US_BIRTH?: boolean
    US_GENDER?: boolean
    US_ADDRESS?: boolean
    USER_ACCOUNT?: boolean | USER_ACCOUNTArgs
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERFindManyArgs
    _count?: boolean | USER_INFOCountOutputTypeArgs
  }

  export type USER_INFOInclude = {
    USER_ACCOUNT?: boolean | USER_ACCOUNTArgs
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERFindManyArgs
    _count?: boolean | USER_INFOCountOutputTypeArgs
  }

  export type USER_INFOGetPayload<
    S extends boolean | null | undefined | USER_INFOArgs,
    U = keyof S
      > = S extends true
        ? USER_INFO
    : S extends undefined
    ? never
    : S extends USER_INFOArgs | USER_INFOFindManyArgs
    ?'include' extends U
    ? USER_INFO  & {
    [P in TrueKeys<S['include']>]:
        P extends 'USER_ACCOUNT' ? USER_ACCOUNTGetPayload<S['include'][P]> :
        P extends 'PROJECT_MEMBER' ? Array < PROJECT_MEMBERGetPayload<S['include'][P]>>  :
        P extends '_count' ? USER_INFOCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'USER_ACCOUNT' ? USER_ACCOUNTGetPayload<S['select'][P]> :
        P extends 'PROJECT_MEMBER' ? Array < PROJECT_MEMBERGetPayload<S['select'][P]>>  :
        P extends '_count' ? USER_INFOCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof USER_INFO ? USER_INFO[P] : never
  } 
    : USER_INFO
  : USER_INFO


  type USER_INFOCountArgs = Merge<
    Omit<USER_INFOFindManyArgs, 'select' | 'include'> & {
      select?: USER_INFOCountAggregateInputType | true
    }
  >

  export interface USER_INFODelegate<GlobalRejectSettings> {
    /**
     * Find zero or one USER_INFO that matches the filter.
     * @param {USER_INFOFindUniqueArgs} args - Arguments to find a USER_INFO
     * @example
     * // Get one USER_INFO
     * const uSER_INFO = await prisma.uSER_INFO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends USER_INFOFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, USER_INFOFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'USER_INFO'> extends True ? CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>> : CheckSelect<T, Prisma__USER_INFOClient<USER_INFO | null >, Prisma__USER_INFOClient<USER_INFOGetPayload<T> | null >>

    /**
     * Find the first USER_INFO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOFindFirstArgs} args - Arguments to find a USER_INFO
     * @example
     * // Get one USER_INFO
     * const uSER_INFO = await prisma.uSER_INFO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends USER_INFOFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, USER_INFOFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'USER_INFO'> extends True ? CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>> : CheckSelect<T, Prisma__USER_INFOClient<USER_INFO | null >, Prisma__USER_INFOClient<USER_INFOGetPayload<T> | null >>

    /**
     * Find zero or more USER_INFOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all USER_INFOS
     * const uSER_INFOS = await prisma.uSER_INFO.findMany()
     * 
     * // Get first 10 USER_INFOS
     * const uSER_INFOS = await prisma.uSER_INFO.findMany({ take: 10 })
     * 
     * // Only select the `US_ID`
     * const uSER_INFOWithUS_IDOnly = await prisma.uSER_INFO.findMany({ select: { US_ID: true } })
     * 
    **/
    findMany<T extends USER_INFOFindManyArgs>(
      args?: SelectSubset<T, USER_INFOFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<USER_INFO>>, PrismaPromise<Array<USER_INFOGetPayload<T>>>>

    /**
     * Create a USER_INFO.
     * @param {USER_INFOCreateArgs} args - Arguments to create a USER_INFO.
     * @example
     * // Create one USER_INFO
     * const USER_INFO = await prisma.uSER_INFO.create({
     *   data: {
     *     // ... data to create a USER_INFO
     *   }
     * })
     * 
    **/
    create<T extends USER_INFOCreateArgs>(
      args: SelectSubset<T, USER_INFOCreateArgs>
    ): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>>

    /**
     * Create many USER_INFOS.
     *     @param {USER_INFOCreateManyArgs} args - Arguments to create many USER_INFOS.
     *     @example
     *     // Create many USER_INFOS
     *     const uSER_INFO = await prisma.uSER_INFO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends USER_INFOCreateManyArgs>(
      args?: SelectSubset<T, USER_INFOCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a USER_INFO.
     * @param {USER_INFODeleteArgs} args - Arguments to delete one USER_INFO.
     * @example
     * // Delete one USER_INFO
     * const USER_INFO = await prisma.uSER_INFO.delete({
     *   where: {
     *     // ... filter to delete one USER_INFO
     *   }
     * })
     * 
    **/
    delete<T extends USER_INFODeleteArgs>(
      args: SelectSubset<T, USER_INFODeleteArgs>
    ): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>>

    /**
     * Update one USER_INFO.
     * @param {USER_INFOUpdateArgs} args - Arguments to update one USER_INFO.
     * @example
     * // Update one USER_INFO
     * const uSER_INFO = await prisma.uSER_INFO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends USER_INFOUpdateArgs>(
      args: SelectSubset<T, USER_INFOUpdateArgs>
    ): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>>

    /**
     * Delete zero or more USER_INFOS.
     * @param {USER_INFODeleteManyArgs} args - Arguments to filter USER_INFOS to delete.
     * @example
     * // Delete a few USER_INFOS
     * const { count } = await prisma.uSER_INFO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends USER_INFODeleteManyArgs>(
      args?: SelectSubset<T, USER_INFODeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more USER_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many USER_INFOS
     * const uSER_INFO = await prisma.uSER_INFO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends USER_INFOUpdateManyArgs>(
      args: SelectSubset<T, USER_INFOUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one USER_INFO.
     * @param {USER_INFOUpsertArgs} args - Arguments to update or create a USER_INFO.
     * @example
     * // Update or create a USER_INFO
     * const uSER_INFO = await prisma.uSER_INFO.upsert({
     *   create: {
     *     // ... data to create a USER_INFO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the USER_INFO we want to update
     *   }
     * })
    **/
    upsert<T extends USER_INFOUpsertArgs>(
      args: SelectSubset<T, USER_INFOUpsertArgs>
    ): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>>

    /**
     * Find one USER_INFO that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {USER_INFOFindUniqueOrThrowArgs} args - Arguments to find a USER_INFO
     * @example
     * // Get one USER_INFO
     * const uSER_INFO = await prisma.uSER_INFO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends USER_INFOFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, USER_INFOFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>>

    /**
     * Find the first USER_INFO that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOFindFirstOrThrowArgs} args - Arguments to find a USER_INFO
     * @example
     * // Get one USER_INFO
     * const uSER_INFO = await prisma.uSER_INFO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends USER_INFOFindFirstOrThrowArgs>(
      args?: SelectSubset<T, USER_INFOFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO>, Prisma__USER_INFOClient<USER_INFOGetPayload<T>>>

    /**
     * Count the number of USER_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOCountArgs} args - Arguments to filter USER_INFOS to count.
     * @example
     * // Count the number of USER_INFOS
     * const count = await prisma.uSER_INFO.count({
     *   where: {
     *     // ... the filter for the USER_INFOS we want to count
     *   }
     * })
    **/
    count<T extends USER_INFOCountArgs>(
      args?: Subset<T, USER_INFOCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], USER_INFOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a USER_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends USER_INFOAggregateArgs>(args: Subset<T, USER_INFOAggregateArgs>): PrismaPromise<GetUSER_INFOAggregateType<T>>

    /**
     * Group by USER_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_INFOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends USER_INFOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: USER_INFOGroupByArgs['orderBy'] }
        : { orderBy?: USER_INFOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, USER_INFOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUSER_INFOGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for USER_INFO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__USER_INFOClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    USER_ACCOUNT<T extends USER_ACCOUNTArgs = {}>(args?: Subset<T, USER_ACCOUNTArgs>): CheckSelect<T, Prisma__USER_ACCOUNTClient<USER_ACCOUNT | null >, Prisma__USER_ACCOUNTClient<USER_ACCOUNTGetPayload<T> | null >>;

    PROJECT_MEMBER<T extends PROJECT_MEMBERFindManyArgs = {}>(args?: Subset<T, PROJECT_MEMBERFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PROJECT_MEMBER>>, PrismaPromise<Array<PROJECT_MEMBERGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * USER_INFO base type for findUnique actions
   */
  export type USER_INFOFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * Filter, which USER_INFO to fetch.
     * 
    **/
    where: USER_INFOWhereUniqueInput
  }

  /**
   * USER_INFO: findUnique
   */
  export interface USER_INFOFindUniqueArgs extends USER_INFOFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * USER_INFO base type for findFirst actions
   */
  export type USER_INFOFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * Filter, which USER_INFO to fetch.
     * 
    **/
    where?: USER_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<USER_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USER_INFOS.
     * 
    **/
    cursor?: USER_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_INFOS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USER_INFOS.
     * 
    **/
    distinct?: Enumerable<USER_INFOScalarFieldEnum>
  }

  /**
   * USER_INFO: findFirst
   */
  export interface USER_INFOFindFirstArgs extends USER_INFOFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * USER_INFO findMany
   */
  export type USER_INFOFindManyArgs = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * Filter, which USER_INFOS to fetch.
     * 
    **/
    where?: USER_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<USER_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing USER_INFOS.
     * 
    **/
    cursor?: USER_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_INFOS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<USER_INFOScalarFieldEnum>
  }


  /**
   * USER_INFO create
   */
  export type USER_INFOCreateArgs = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * The data needed to create a USER_INFO.
     * 
    **/
    data: XOR<USER_INFOCreateInput, USER_INFOUncheckedCreateInput>
  }


  /**
   * USER_INFO createMany
   */
  export type USER_INFOCreateManyArgs = {
    /**
     * The data used to create many USER_INFOS.
     * 
    **/
    data: Enumerable<USER_INFOCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * USER_INFO update
   */
  export type USER_INFOUpdateArgs = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * The data needed to update a USER_INFO.
     * 
    **/
    data: XOR<USER_INFOUpdateInput, USER_INFOUncheckedUpdateInput>
    /**
     * Choose, which USER_INFO to update.
     * 
    **/
    where: USER_INFOWhereUniqueInput
  }


  /**
   * USER_INFO updateMany
   */
  export type USER_INFOUpdateManyArgs = {
    /**
     * The data used to update USER_INFOS.
     * 
    **/
    data: XOR<USER_INFOUpdateManyMutationInput, USER_INFOUncheckedUpdateManyInput>
    /**
     * Filter which USER_INFOS to update
     * 
    **/
    where?: USER_INFOWhereInput
  }


  /**
   * USER_INFO upsert
   */
  export type USER_INFOUpsertArgs = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * The filter to search for the USER_INFO to update in case it exists.
     * 
    **/
    where: USER_INFOWhereUniqueInput
    /**
     * In case the USER_INFO found by the `where` argument doesn't exist, create a new USER_INFO with this data.
     * 
    **/
    create: XOR<USER_INFOCreateInput, USER_INFOUncheckedCreateInput>
    /**
     * In case the USER_INFO was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<USER_INFOUpdateInput, USER_INFOUncheckedUpdateInput>
  }


  /**
   * USER_INFO delete
   */
  export type USER_INFODeleteArgs = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
    /**
     * Filter which USER_INFO to delete.
     * 
    **/
    where: USER_INFOWhereUniqueInput
  }


  /**
   * USER_INFO deleteMany
   */
  export type USER_INFODeleteManyArgs = {
    /**
     * Filter which USER_INFOS to delete
     * 
    **/
    where?: USER_INFOWhereInput
  }


  /**
   * USER_INFO: findUniqueOrThrow
   */
  export type USER_INFOFindUniqueOrThrowArgs = USER_INFOFindUniqueArgsBase
      

  /**
   * USER_INFO: findFirstOrThrow
   */
  export type USER_INFOFindFirstOrThrowArgs = USER_INFOFindFirstArgsBase
      

  /**
   * USER_INFO without action
   */
  export type USER_INFOArgs = {
    /**
     * Select specific fields to fetch from the USER_INFO
     * 
    **/
    select?: USER_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: USER_INFOInclude | null
  }



  /**
   * Model PROJECT_ACCESSIBILITY
   */


  export type AggregatePROJECT_ACCESSIBILITY = {
    _count: PROJECT_ACCESSIBILITYCountAggregateOutputType | null
    _avg: PROJECT_ACCESSIBILITYAvgAggregateOutputType | null
    _sum: PROJECT_ACCESSIBILITYSumAggregateOutputType | null
    _min: PROJECT_ACCESSIBILITYMinAggregateOutputType | null
    _max: PROJECT_ACCESSIBILITYMaxAggregateOutputType | null
  }

  export type PROJECT_ACCESSIBILITYAvgAggregateOutputType = {
    MEM_POS: number | null
  }

  export type PROJECT_ACCESSIBILITYSumAggregateOutputType = {
    MEM_POS: bigint | null
  }

  export type PROJECT_ACCESSIBILITYMinAggregateOutputType = {
    MEM_POS: bigint | null
    DEL_PJ: string | null
    EDIT_MEM_POS: string | null
    EDIT_MEM: string | null
    EDIT_STATUS: string | null
    CREATE_ANNOUNC_MNT: string | null
  }

  export type PROJECT_ACCESSIBILITYMaxAggregateOutputType = {
    MEM_POS: bigint | null
    DEL_PJ: string | null
    EDIT_MEM_POS: string | null
    EDIT_MEM: string | null
    EDIT_STATUS: string | null
    CREATE_ANNOUNC_MNT: string | null
  }

  export type PROJECT_ACCESSIBILITYCountAggregateOutputType = {
    MEM_POS: number
    DEL_PJ: number
    EDIT_MEM_POS: number
    EDIT_MEM: number
    EDIT_STATUS: number
    CREATE_ANNOUNC_MNT: number
    _all: number
  }


  export type PROJECT_ACCESSIBILITYAvgAggregateInputType = {
    MEM_POS?: true
  }

  export type PROJECT_ACCESSIBILITYSumAggregateInputType = {
    MEM_POS?: true
  }

  export type PROJECT_ACCESSIBILITYMinAggregateInputType = {
    MEM_POS?: true
    DEL_PJ?: true
    EDIT_MEM_POS?: true
    EDIT_MEM?: true
    EDIT_STATUS?: true
    CREATE_ANNOUNC_MNT?: true
  }

  export type PROJECT_ACCESSIBILITYMaxAggregateInputType = {
    MEM_POS?: true
    DEL_PJ?: true
    EDIT_MEM_POS?: true
    EDIT_MEM?: true
    EDIT_STATUS?: true
    CREATE_ANNOUNC_MNT?: true
  }

  export type PROJECT_ACCESSIBILITYCountAggregateInputType = {
    MEM_POS?: true
    DEL_PJ?: true
    EDIT_MEM_POS?: true
    EDIT_MEM?: true
    EDIT_STATUS?: true
    CREATE_ANNOUNC_MNT?: true
    _all?: true
  }

  export type PROJECT_ACCESSIBILITYAggregateArgs = {
    /**
     * Filter which PROJECT_ACCESSIBILITY to aggregate.
     * 
    **/
    where?: PROJECT_ACCESSIBILITYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_ACCESSIBILITIES to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_ACCESSIBILITYOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PROJECT_ACCESSIBILITYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_ACCESSIBILITIES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_ACCESSIBILITIES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PROJECT_ACCESSIBILITIES
    **/
    _count?: true | PROJECT_ACCESSIBILITYCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PROJECT_ACCESSIBILITYAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PROJECT_ACCESSIBILITYSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PROJECT_ACCESSIBILITYMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PROJECT_ACCESSIBILITYMaxAggregateInputType
  }

  export type GetPROJECT_ACCESSIBILITYAggregateType<T extends PROJECT_ACCESSIBILITYAggregateArgs> = {
        [P in keyof T & keyof AggregatePROJECT_ACCESSIBILITY]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePROJECT_ACCESSIBILITY[P]>
      : GetScalarType<T[P], AggregatePROJECT_ACCESSIBILITY[P]>
  }




  export type PROJECT_ACCESSIBILITYGroupByArgs = {
    where?: PROJECT_ACCESSIBILITYWhereInput
    orderBy?: Enumerable<PROJECT_ACCESSIBILITYOrderByWithAggregationInput>
    by: Array<PROJECT_ACCESSIBILITYScalarFieldEnum>
    having?: PROJECT_ACCESSIBILITYScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PROJECT_ACCESSIBILITYCountAggregateInputType | true
    _avg?: PROJECT_ACCESSIBILITYAvgAggregateInputType
    _sum?: PROJECT_ACCESSIBILITYSumAggregateInputType
    _min?: PROJECT_ACCESSIBILITYMinAggregateInputType
    _max?: PROJECT_ACCESSIBILITYMaxAggregateInputType
  }


  export type PROJECT_ACCESSIBILITYGroupByOutputType = {
    MEM_POS: bigint
    DEL_PJ: string | null
    EDIT_MEM_POS: string | null
    EDIT_MEM: string | null
    EDIT_STATUS: string | null
    CREATE_ANNOUNC_MNT: string | null
    _count: PROJECT_ACCESSIBILITYCountAggregateOutputType | null
    _avg: PROJECT_ACCESSIBILITYAvgAggregateOutputType | null
    _sum: PROJECT_ACCESSIBILITYSumAggregateOutputType | null
    _min: PROJECT_ACCESSIBILITYMinAggregateOutputType | null
    _max: PROJECT_ACCESSIBILITYMaxAggregateOutputType | null
  }

  type GetPROJECT_ACCESSIBILITYGroupByPayload<T extends PROJECT_ACCESSIBILITYGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PROJECT_ACCESSIBILITYGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PROJECT_ACCESSIBILITYGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PROJECT_ACCESSIBILITYGroupByOutputType[P]>
            : GetScalarType<T[P], PROJECT_ACCESSIBILITYGroupByOutputType[P]>
        }
      >
    >


  export type PROJECT_ACCESSIBILITYSelect = {
    MEM_POS?: boolean
    DEL_PJ?: boolean
    EDIT_MEM_POS?: boolean
    EDIT_MEM?: boolean
    EDIT_STATUS?: boolean
    CREATE_ANNOUNC_MNT?: boolean
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERFindManyArgs
    _count?: boolean | PROJECT_ACCESSIBILITYCountOutputTypeArgs
  }

  export type PROJECT_ACCESSIBILITYInclude = {
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERFindManyArgs
    _count?: boolean | PROJECT_ACCESSIBILITYCountOutputTypeArgs
  }

  export type PROJECT_ACCESSIBILITYGetPayload<
    S extends boolean | null | undefined | PROJECT_ACCESSIBILITYArgs,
    U = keyof S
      > = S extends true
        ? PROJECT_ACCESSIBILITY
    : S extends undefined
    ? never
    : S extends PROJECT_ACCESSIBILITYArgs | PROJECT_ACCESSIBILITYFindManyArgs
    ?'include' extends U
    ? PROJECT_ACCESSIBILITY  & {
    [P in TrueKeys<S['include']>]:
        P extends 'PROJECT_MEMBER' ? Array < PROJECT_MEMBERGetPayload<S['include'][P]>>  :
        P extends '_count' ? PROJECT_ACCESSIBILITYCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'PROJECT_MEMBER' ? Array < PROJECT_MEMBERGetPayload<S['select'][P]>>  :
        P extends '_count' ? PROJECT_ACCESSIBILITYCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PROJECT_ACCESSIBILITY ? PROJECT_ACCESSIBILITY[P] : never
  } 
    : PROJECT_ACCESSIBILITY
  : PROJECT_ACCESSIBILITY


  type PROJECT_ACCESSIBILITYCountArgs = Merge<
    Omit<PROJECT_ACCESSIBILITYFindManyArgs, 'select' | 'include'> & {
      select?: PROJECT_ACCESSIBILITYCountAggregateInputType | true
    }
  >

  export interface PROJECT_ACCESSIBILITYDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PROJECT_ACCESSIBILITY that matches the filter.
     * @param {PROJECT_ACCESSIBILITYFindUniqueArgs} args - Arguments to find a PROJECT_ACCESSIBILITY
     * @example
     * // Get one PROJECT_ACCESSIBILITY
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PROJECT_ACCESSIBILITYFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PROJECT_ACCESSIBILITYFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PROJECT_ACCESSIBILITY'> extends True ? CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>> : CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY | null >, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T> | null >>

    /**
     * Find the first PROJECT_ACCESSIBILITY that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYFindFirstArgs} args - Arguments to find a PROJECT_ACCESSIBILITY
     * @example
     * // Get one PROJECT_ACCESSIBILITY
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PROJECT_ACCESSIBILITYFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PROJECT_ACCESSIBILITYFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PROJECT_ACCESSIBILITY'> extends True ? CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>> : CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY | null >, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T> | null >>

    /**
     * Find zero or more PROJECT_ACCESSIBILITIES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PROJECT_ACCESSIBILITIES
     * const pROJECT_ACCESSIBILITIES = await prisma.pROJECT_ACCESSIBILITY.findMany()
     * 
     * // Get first 10 PROJECT_ACCESSIBILITIES
     * const pROJECT_ACCESSIBILITIES = await prisma.pROJECT_ACCESSIBILITY.findMany({ take: 10 })
     * 
     * // Only select the `MEM_POS`
     * const pROJECT_ACCESSIBILITYWithMEM_POSOnly = await prisma.pROJECT_ACCESSIBILITY.findMany({ select: { MEM_POS: true } })
     * 
    **/
    findMany<T extends PROJECT_ACCESSIBILITYFindManyArgs>(
      args?: SelectSubset<T, PROJECT_ACCESSIBILITYFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PROJECT_ACCESSIBILITY>>, PrismaPromise<Array<PROJECT_ACCESSIBILITYGetPayload<T>>>>

    /**
     * Create a PROJECT_ACCESSIBILITY.
     * @param {PROJECT_ACCESSIBILITYCreateArgs} args - Arguments to create a PROJECT_ACCESSIBILITY.
     * @example
     * // Create one PROJECT_ACCESSIBILITY
     * const PROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.create({
     *   data: {
     *     // ... data to create a PROJECT_ACCESSIBILITY
     *   }
     * })
     * 
    **/
    create<T extends PROJECT_ACCESSIBILITYCreateArgs>(
      args: SelectSubset<T, PROJECT_ACCESSIBILITYCreateArgs>
    ): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>>

    /**
     * Create many PROJECT_ACCESSIBILITIES.
     *     @param {PROJECT_ACCESSIBILITYCreateManyArgs} args - Arguments to create many PROJECT_ACCESSIBILITIES.
     *     @example
     *     // Create many PROJECT_ACCESSIBILITIES
     *     const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PROJECT_ACCESSIBILITYCreateManyArgs>(
      args?: SelectSubset<T, PROJECT_ACCESSIBILITYCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PROJECT_ACCESSIBILITY.
     * @param {PROJECT_ACCESSIBILITYDeleteArgs} args - Arguments to delete one PROJECT_ACCESSIBILITY.
     * @example
     * // Delete one PROJECT_ACCESSIBILITY
     * const PROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.delete({
     *   where: {
     *     // ... filter to delete one PROJECT_ACCESSIBILITY
     *   }
     * })
     * 
    **/
    delete<T extends PROJECT_ACCESSIBILITYDeleteArgs>(
      args: SelectSubset<T, PROJECT_ACCESSIBILITYDeleteArgs>
    ): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>>

    /**
     * Update one PROJECT_ACCESSIBILITY.
     * @param {PROJECT_ACCESSIBILITYUpdateArgs} args - Arguments to update one PROJECT_ACCESSIBILITY.
     * @example
     * // Update one PROJECT_ACCESSIBILITY
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PROJECT_ACCESSIBILITYUpdateArgs>(
      args: SelectSubset<T, PROJECT_ACCESSIBILITYUpdateArgs>
    ): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>>

    /**
     * Delete zero or more PROJECT_ACCESSIBILITIES.
     * @param {PROJECT_ACCESSIBILITYDeleteManyArgs} args - Arguments to filter PROJECT_ACCESSIBILITIES to delete.
     * @example
     * // Delete a few PROJECT_ACCESSIBILITIES
     * const { count } = await prisma.pROJECT_ACCESSIBILITY.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PROJECT_ACCESSIBILITYDeleteManyArgs>(
      args?: SelectSubset<T, PROJECT_ACCESSIBILITYDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PROJECT_ACCESSIBILITIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PROJECT_ACCESSIBILITIES
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PROJECT_ACCESSIBILITYUpdateManyArgs>(
      args: SelectSubset<T, PROJECT_ACCESSIBILITYUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PROJECT_ACCESSIBILITY.
     * @param {PROJECT_ACCESSIBILITYUpsertArgs} args - Arguments to update or create a PROJECT_ACCESSIBILITY.
     * @example
     * // Update or create a PROJECT_ACCESSIBILITY
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.upsert({
     *   create: {
     *     // ... data to create a PROJECT_ACCESSIBILITY
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PROJECT_ACCESSIBILITY we want to update
     *   }
     * })
    **/
    upsert<T extends PROJECT_ACCESSIBILITYUpsertArgs>(
      args: SelectSubset<T, PROJECT_ACCESSIBILITYUpsertArgs>
    ): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>>

    /**
     * Find one PROJECT_ACCESSIBILITY that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PROJECT_ACCESSIBILITYFindUniqueOrThrowArgs} args - Arguments to find a PROJECT_ACCESSIBILITY
     * @example
     * // Get one PROJECT_ACCESSIBILITY
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PROJECT_ACCESSIBILITYFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PROJECT_ACCESSIBILITYFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>>

    /**
     * Find the first PROJECT_ACCESSIBILITY that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYFindFirstOrThrowArgs} args - Arguments to find a PROJECT_ACCESSIBILITY
     * @example
     * // Get one PROJECT_ACCESSIBILITY
     * const pROJECT_ACCESSIBILITY = await prisma.pROJECT_ACCESSIBILITY.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PROJECT_ACCESSIBILITYFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PROJECT_ACCESSIBILITYFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY>, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T>>>

    /**
     * Count the number of PROJECT_ACCESSIBILITIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYCountArgs} args - Arguments to filter PROJECT_ACCESSIBILITIES to count.
     * @example
     * // Count the number of PROJECT_ACCESSIBILITIES
     * const count = await prisma.pROJECT_ACCESSIBILITY.count({
     *   where: {
     *     // ... the filter for the PROJECT_ACCESSIBILITIES we want to count
     *   }
     * })
    **/
    count<T extends PROJECT_ACCESSIBILITYCountArgs>(
      args?: Subset<T, PROJECT_ACCESSIBILITYCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PROJECT_ACCESSIBILITYCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PROJECT_ACCESSIBILITY.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PROJECT_ACCESSIBILITYAggregateArgs>(args: Subset<T, PROJECT_ACCESSIBILITYAggregateArgs>): PrismaPromise<GetPROJECT_ACCESSIBILITYAggregateType<T>>

    /**
     * Group by PROJECT_ACCESSIBILITY.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_ACCESSIBILITYGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PROJECT_ACCESSIBILITYGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PROJECT_ACCESSIBILITYGroupByArgs['orderBy'] }
        : { orderBy?: PROJECT_ACCESSIBILITYGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PROJECT_ACCESSIBILITYGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPROJECT_ACCESSIBILITYGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PROJECT_ACCESSIBILITY.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PROJECT_ACCESSIBILITYClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PROJECT_MEMBER<T extends PROJECT_MEMBERFindManyArgs = {}>(args?: Subset<T, PROJECT_MEMBERFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PROJECT_MEMBER>>, PrismaPromise<Array<PROJECT_MEMBERGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PROJECT_ACCESSIBILITY base type for findUnique actions
   */
  export type PROJECT_ACCESSIBILITYFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * Filter, which PROJECT_ACCESSIBILITY to fetch.
     * 
    **/
    where: PROJECT_ACCESSIBILITYWhereUniqueInput
  }

  /**
   * PROJECT_ACCESSIBILITY: findUnique
   */
  export interface PROJECT_ACCESSIBILITYFindUniqueArgs extends PROJECT_ACCESSIBILITYFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PROJECT_ACCESSIBILITY base type for findFirst actions
   */
  export type PROJECT_ACCESSIBILITYFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * Filter, which PROJECT_ACCESSIBILITY to fetch.
     * 
    **/
    where?: PROJECT_ACCESSIBILITYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_ACCESSIBILITIES to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_ACCESSIBILITYOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PROJECT_ACCESSIBILITIES.
     * 
    **/
    cursor?: PROJECT_ACCESSIBILITYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_ACCESSIBILITIES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_ACCESSIBILITIES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PROJECT_ACCESSIBILITIES.
     * 
    **/
    distinct?: Enumerable<PROJECT_ACCESSIBILITYScalarFieldEnum>
  }

  /**
   * PROJECT_ACCESSIBILITY: findFirst
   */
  export interface PROJECT_ACCESSIBILITYFindFirstArgs extends PROJECT_ACCESSIBILITYFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PROJECT_ACCESSIBILITY findMany
   */
  export type PROJECT_ACCESSIBILITYFindManyArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * Filter, which PROJECT_ACCESSIBILITIES to fetch.
     * 
    **/
    where?: PROJECT_ACCESSIBILITYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_ACCESSIBILITIES to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_ACCESSIBILITYOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PROJECT_ACCESSIBILITIES.
     * 
    **/
    cursor?: PROJECT_ACCESSIBILITYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_ACCESSIBILITIES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_ACCESSIBILITIES.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PROJECT_ACCESSIBILITYScalarFieldEnum>
  }


  /**
   * PROJECT_ACCESSIBILITY create
   */
  export type PROJECT_ACCESSIBILITYCreateArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * The data needed to create a PROJECT_ACCESSIBILITY.
     * 
    **/
    data: XOR<PROJECT_ACCESSIBILITYCreateInput, PROJECT_ACCESSIBILITYUncheckedCreateInput>
  }


  /**
   * PROJECT_ACCESSIBILITY createMany
   */
  export type PROJECT_ACCESSIBILITYCreateManyArgs = {
    /**
     * The data used to create many PROJECT_ACCESSIBILITIES.
     * 
    **/
    data: Enumerable<PROJECT_ACCESSIBILITYCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PROJECT_ACCESSIBILITY update
   */
  export type PROJECT_ACCESSIBILITYUpdateArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * The data needed to update a PROJECT_ACCESSIBILITY.
     * 
    **/
    data: XOR<PROJECT_ACCESSIBILITYUpdateInput, PROJECT_ACCESSIBILITYUncheckedUpdateInput>
    /**
     * Choose, which PROJECT_ACCESSIBILITY to update.
     * 
    **/
    where: PROJECT_ACCESSIBILITYWhereUniqueInput
  }


  /**
   * PROJECT_ACCESSIBILITY updateMany
   */
  export type PROJECT_ACCESSIBILITYUpdateManyArgs = {
    /**
     * The data used to update PROJECT_ACCESSIBILITIES.
     * 
    **/
    data: XOR<PROJECT_ACCESSIBILITYUpdateManyMutationInput, PROJECT_ACCESSIBILITYUncheckedUpdateManyInput>
    /**
     * Filter which PROJECT_ACCESSIBILITIES to update
     * 
    **/
    where?: PROJECT_ACCESSIBILITYWhereInput
  }


  /**
   * PROJECT_ACCESSIBILITY upsert
   */
  export type PROJECT_ACCESSIBILITYUpsertArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * The filter to search for the PROJECT_ACCESSIBILITY to update in case it exists.
     * 
    **/
    where: PROJECT_ACCESSIBILITYWhereUniqueInput
    /**
     * In case the PROJECT_ACCESSIBILITY found by the `where` argument doesn't exist, create a new PROJECT_ACCESSIBILITY with this data.
     * 
    **/
    create: XOR<PROJECT_ACCESSIBILITYCreateInput, PROJECT_ACCESSIBILITYUncheckedCreateInput>
    /**
     * In case the PROJECT_ACCESSIBILITY was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PROJECT_ACCESSIBILITYUpdateInput, PROJECT_ACCESSIBILITYUncheckedUpdateInput>
  }


  /**
   * PROJECT_ACCESSIBILITY delete
   */
  export type PROJECT_ACCESSIBILITYDeleteArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
    /**
     * Filter which PROJECT_ACCESSIBILITY to delete.
     * 
    **/
    where: PROJECT_ACCESSIBILITYWhereUniqueInput
  }


  /**
   * PROJECT_ACCESSIBILITY deleteMany
   */
  export type PROJECT_ACCESSIBILITYDeleteManyArgs = {
    /**
     * Filter which PROJECT_ACCESSIBILITIES to delete
     * 
    **/
    where?: PROJECT_ACCESSIBILITYWhereInput
  }


  /**
   * PROJECT_ACCESSIBILITY: findUniqueOrThrow
   */
  export type PROJECT_ACCESSIBILITYFindUniqueOrThrowArgs = PROJECT_ACCESSIBILITYFindUniqueArgsBase
      

  /**
   * PROJECT_ACCESSIBILITY: findFirstOrThrow
   */
  export type PROJECT_ACCESSIBILITYFindFirstOrThrowArgs = PROJECT_ACCESSIBILITYFindFirstArgsBase
      

  /**
   * PROJECT_ACCESSIBILITY without action
   */
  export type PROJECT_ACCESSIBILITYArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_ACCESSIBILITY
     * 
    **/
    select?: PROJECT_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_ACCESSIBILITYInclude | null
  }



  /**
   * Model PROJECT_INFO
   */


  export type AggregatePROJECT_INFO = {
    _count: PROJECT_INFOCountAggregateOutputType | null
    _avg: PROJECT_INFOAvgAggregateOutputType | null
    _sum: PROJECT_INFOSumAggregateOutputType | null
    _min: PROJECT_INFOMinAggregateOutputType | null
    _max: PROJECT_INFOMaxAggregateOutputType | null
  }

  export type PROJECT_INFOAvgAggregateOutputType = {
    PJ_ID: number | null
    PJ_ADMIN: number | null
  }

  export type PROJECT_INFOSumAggregateOutputType = {
    PJ_ID: bigint | null
    PJ_ADMIN: bigint | null
  }

  export type PROJECT_INFOMinAggregateOutputType = {
    PJ_ID: bigint | null
    PJ_NAME: string | null
    PJ_CREATEDAY: Date | null
    PJ_DEADLINE: Date | null
    PJ_STATUS: string | null
    PJ_ADMIN: bigint | null
    PJ_OWNER: string | null
  }

  export type PROJECT_INFOMaxAggregateOutputType = {
    PJ_ID: bigint | null
    PJ_NAME: string | null
    PJ_CREATEDAY: Date | null
    PJ_DEADLINE: Date | null
    PJ_STATUS: string | null
    PJ_ADMIN: bigint | null
    PJ_OWNER: string | null
  }

  export type PROJECT_INFOCountAggregateOutputType = {
    PJ_ID: number
    PJ_NAME: number
    PJ_CREATEDAY: number
    PJ_DEADLINE: number
    PJ_STATUS: number
    PJ_ADMIN: number
    PJ_OWNER: number
    _all: number
  }


  export type PROJECT_INFOAvgAggregateInputType = {
    PJ_ID?: true
    PJ_ADMIN?: true
  }

  export type PROJECT_INFOSumAggregateInputType = {
    PJ_ID?: true
    PJ_ADMIN?: true
  }

  export type PROJECT_INFOMinAggregateInputType = {
    PJ_ID?: true
    PJ_NAME?: true
    PJ_CREATEDAY?: true
    PJ_DEADLINE?: true
    PJ_STATUS?: true
    PJ_ADMIN?: true
    PJ_OWNER?: true
  }

  export type PROJECT_INFOMaxAggregateInputType = {
    PJ_ID?: true
    PJ_NAME?: true
    PJ_CREATEDAY?: true
    PJ_DEADLINE?: true
    PJ_STATUS?: true
    PJ_ADMIN?: true
    PJ_OWNER?: true
  }

  export type PROJECT_INFOCountAggregateInputType = {
    PJ_ID?: true
    PJ_NAME?: true
    PJ_CREATEDAY?: true
    PJ_DEADLINE?: true
    PJ_STATUS?: true
    PJ_ADMIN?: true
    PJ_OWNER?: true
    _all?: true
  }

  export type PROJECT_INFOAggregateArgs = {
    /**
     * Filter which PROJECT_INFO to aggregate.
     * 
    **/
    where?: PROJECT_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PROJECT_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_INFOS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PROJECT_INFOS
    **/
    _count?: true | PROJECT_INFOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PROJECT_INFOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PROJECT_INFOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PROJECT_INFOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PROJECT_INFOMaxAggregateInputType
  }

  export type GetPROJECT_INFOAggregateType<T extends PROJECT_INFOAggregateArgs> = {
        [P in keyof T & keyof AggregatePROJECT_INFO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePROJECT_INFO[P]>
      : GetScalarType<T[P], AggregatePROJECT_INFO[P]>
  }




  export type PROJECT_INFOGroupByArgs = {
    where?: PROJECT_INFOWhereInput
    orderBy?: Enumerable<PROJECT_INFOOrderByWithAggregationInput>
    by: Array<PROJECT_INFOScalarFieldEnum>
    having?: PROJECT_INFOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PROJECT_INFOCountAggregateInputType | true
    _avg?: PROJECT_INFOAvgAggregateInputType
    _sum?: PROJECT_INFOSumAggregateInputType
    _min?: PROJECT_INFOMinAggregateInputType
    _max?: PROJECT_INFOMaxAggregateInputType
  }


  export type PROJECT_INFOGroupByOutputType = {
    PJ_ID: bigint
    PJ_NAME: string | null
    PJ_CREATEDAY: Date | null
    PJ_DEADLINE: Date | null
    PJ_STATUS: string | null
    PJ_ADMIN: bigint | null
    PJ_OWNER: string | null
    _count: PROJECT_INFOCountAggregateOutputType | null
    _avg: PROJECT_INFOAvgAggregateOutputType | null
    _sum: PROJECT_INFOSumAggregateOutputType | null
    _min: PROJECT_INFOMinAggregateOutputType | null
    _max: PROJECT_INFOMaxAggregateOutputType | null
  }

  type GetPROJECT_INFOGroupByPayload<T extends PROJECT_INFOGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PROJECT_INFOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PROJECT_INFOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PROJECT_INFOGroupByOutputType[P]>
            : GetScalarType<T[P], PROJECT_INFOGroupByOutputType[P]>
        }
      >
    >


  export type PROJECT_INFOSelect = {
    PJ_ID?: boolean
    PJ_NAME?: boolean
    PJ_CREATEDAY?: boolean
    PJ_DEADLINE?: boolean
    PJ_STATUS?: boolean
    PJ_ADMIN?: boolean
    PJ_OWNER?: boolean
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: boolean | PROJECT_MEMBERArgs
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: boolean | PROJECT_MEMBERFindManyArgs
    TASK_INFO?: boolean | TASK_INFOFindManyArgs
    _count?: boolean | PROJECT_INFOCountOutputTypeArgs
  }

  export type PROJECT_INFOInclude = {
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: boolean | PROJECT_MEMBERArgs
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: boolean | PROJECT_MEMBERFindManyArgs
    TASK_INFO?: boolean | TASK_INFOFindManyArgs
    _count?: boolean | PROJECT_INFOCountOutputTypeArgs
  }

  export type PROJECT_INFOGetPayload<
    S extends boolean | null | undefined | PROJECT_INFOArgs,
    U = keyof S
      > = S extends true
        ? PROJECT_INFO
    : S extends undefined
    ? never
    : S extends PROJECT_INFOArgs | PROJECT_INFOFindManyArgs
    ?'include' extends U
    ? PROJECT_INFO  & {
    [P in TrueKeys<S['include']>]:
        P extends 'PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER' ? PROJECT_MEMBERGetPayload<S['include'][P]> | null :
        P extends 'PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID' ? Array < PROJECT_MEMBERGetPayload<S['include'][P]>>  :
        P extends 'TASK_INFO' ? Array < TASK_INFOGetPayload<S['include'][P]>>  :
        P extends '_count' ? PROJECT_INFOCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER' ? PROJECT_MEMBERGetPayload<S['select'][P]> | null :
        P extends 'PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID' ? Array < PROJECT_MEMBERGetPayload<S['select'][P]>>  :
        P extends 'TASK_INFO' ? Array < TASK_INFOGetPayload<S['select'][P]>>  :
        P extends '_count' ? PROJECT_INFOCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PROJECT_INFO ? PROJECT_INFO[P] : never
  } 
    : PROJECT_INFO
  : PROJECT_INFO


  type PROJECT_INFOCountArgs = Merge<
    Omit<PROJECT_INFOFindManyArgs, 'select' | 'include'> & {
      select?: PROJECT_INFOCountAggregateInputType | true
    }
  >

  export interface PROJECT_INFODelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PROJECT_INFO that matches the filter.
     * @param {PROJECT_INFOFindUniqueArgs} args - Arguments to find a PROJECT_INFO
     * @example
     * // Get one PROJECT_INFO
     * const pROJECT_INFO = await prisma.pROJECT_INFO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PROJECT_INFOFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PROJECT_INFOFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PROJECT_INFO'> extends True ? CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>> : CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO | null >, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T> | null >>

    /**
     * Find the first PROJECT_INFO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOFindFirstArgs} args - Arguments to find a PROJECT_INFO
     * @example
     * // Get one PROJECT_INFO
     * const pROJECT_INFO = await prisma.pROJECT_INFO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PROJECT_INFOFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PROJECT_INFOFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PROJECT_INFO'> extends True ? CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>> : CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO | null >, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T> | null >>

    /**
     * Find zero or more PROJECT_INFOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PROJECT_INFOS
     * const pROJECT_INFOS = await prisma.pROJECT_INFO.findMany()
     * 
     * // Get first 10 PROJECT_INFOS
     * const pROJECT_INFOS = await prisma.pROJECT_INFO.findMany({ take: 10 })
     * 
     * // Only select the `PJ_ID`
     * const pROJECT_INFOWithPJ_IDOnly = await prisma.pROJECT_INFO.findMany({ select: { PJ_ID: true } })
     * 
    **/
    findMany<T extends PROJECT_INFOFindManyArgs>(
      args?: SelectSubset<T, PROJECT_INFOFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PROJECT_INFO>>, PrismaPromise<Array<PROJECT_INFOGetPayload<T>>>>

    /**
     * Create a PROJECT_INFO.
     * @param {PROJECT_INFOCreateArgs} args - Arguments to create a PROJECT_INFO.
     * @example
     * // Create one PROJECT_INFO
     * const PROJECT_INFO = await prisma.pROJECT_INFO.create({
     *   data: {
     *     // ... data to create a PROJECT_INFO
     *   }
     * })
     * 
    **/
    create<T extends PROJECT_INFOCreateArgs>(
      args: SelectSubset<T, PROJECT_INFOCreateArgs>
    ): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>>

    /**
     * Create many PROJECT_INFOS.
     *     @param {PROJECT_INFOCreateManyArgs} args - Arguments to create many PROJECT_INFOS.
     *     @example
     *     // Create many PROJECT_INFOS
     *     const pROJECT_INFO = await prisma.pROJECT_INFO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PROJECT_INFOCreateManyArgs>(
      args?: SelectSubset<T, PROJECT_INFOCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PROJECT_INFO.
     * @param {PROJECT_INFODeleteArgs} args - Arguments to delete one PROJECT_INFO.
     * @example
     * // Delete one PROJECT_INFO
     * const PROJECT_INFO = await prisma.pROJECT_INFO.delete({
     *   where: {
     *     // ... filter to delete one PROJECT_INFO
     *   }
     * })
     * 
    **/
    delete<T extends PROJECT_INFODeleteArgs>(
      args: SelectSubset<T, PROJECT_INFODeleteArgs>
    ): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>>

    /**
     * Update one PROJECT_INFO.
     * @param {PROJECT_INFOUpdateArgs} args - Arguments to update one PROJECT_INFO.
     * @example
     * // Update one PROJECT_INFO
     * const pROJECT_INFO = await prisma.pROJECT_INFO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PROJECT_INFOUpdateArgs>(
      args: SelectSubset<T, PROJECT_INFOUpdateArgs>
    ): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>>

    /**
     * Delete zero or more PROJECT_INFOS.
     * @param {PROJECT_INFODeleteManyArgs} args - Arguments to filter PROJECT_INFOS to delete.
     * @example
     * // Delete a few PROJECT_INFOS
     * const { count } = await prisma.pROJECT_INFO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PROJECT_INFODeleteManyArgs>(
      args?: SelectSubset<T, PROJECT_INFODeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PROJECT_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PROJECT_INFOS
     * const pROJECT_INFO = await prisma.pROJECT_INFO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PROJECT_INFOUpdateManyArgs>(
      args: SelectSubset<T, PROJECT_INFOUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PROJECT_INFO.
     * @param {PROJECT_INFOUpsertArgs} args - Arguments to update or create a PROJECT_INFO.
     * @example
     * // Update or create a PROJECT_INFO
     * const pROJECT_INFO = await prisma.pROJECT_INFO.upsert({
     *   create: {
     *     // ... data to create a PROJECT_INFO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PROJECT_INFO we want to update
     *   }
     * })
    **/
    upsert<T extends PROJECT_INFOUpsertArgs>(
      args: SelectSubset<T, PROJECT_INFOUpsertArgs>
    ): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>>

    /**
     * Find one PROJECT_INFO that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PROJECT_INFOFindUniqueOrThrowArgs} args - Arguments to find a PROJECT_INFO
     * @example
     * // Get one PROJECT_INFO
     * const pROJECT_INFO = await prisma.pROJECT_INFO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PROJECT_INFOFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PROJECT_INFOFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>>

    /**
     * Find the first PROJECT_INFO that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOFindFirstOrThrowArgs} args - Arguments to find a PROJECT_INFO
     * @example
     * // Get one PROJECT_INFO
     * const pROJECT_INFO = await prisma.pROJECT_INFO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PROJECT_INFOFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PROJECT_INFOFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO>, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T>>>

    /**
     * Count the number of PROJECT_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOCountArgs} args - Arguments to filter PROJECT_INFOS to count.
     * @example
     * // Count the number of PROJECT_INFOS
     * const count = await prisma.pROJECT_INFO.count({
     *   where: {
     *     // ... the filter for the PROJECT_INFOS we want to count
     *   }
     * })
    **/
    count<T extends PROJECT_INFOCountArgs>(
      args?: Subset<T, PROJECT_INFOCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PROJECT_INFOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PROJECT_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PROJECT_INFOAggregateArgs>(args: Subset<T, PROJECT_INFOAggregateArgs>): PrismaPromise<GetPROJECT_INFOAggregateType<T>>

    /**
     * Group by PROJECT_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_INFOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PROJECT_INFOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PROJECT_INFOGroupByArgs['orderBy'] }
        : { orderBy?: PROJECT_INFOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PROJECT_INFOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPROJECT_INFOGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PROJECT_INFO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PROJECT_INFOClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER<T extends PROJECT_MEMBERArgs = {}>(args?: Subset<T, PROJECT_MEMBERArgs>): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER | null >, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T> | null >>;

    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID<T extends PROJECT_MEMBERFindManyArgs = {}>(args?: Subset<T, PROJECT_MEMBERFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PROJECT_MEMBER>>, PrismaPromise<Array<PROJECT_MEMBERGetPayload<T>>>>;

    TASK_INFO<T extends TASK_INFOFindManyArgs = {}>(args?: Subset<T, TASK_INFOFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TASK_INFO>>, PrismaPromise<Array<TASK_INFOGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PROJECT_INFO base type for findUnique actions
   */
  export type PROJECT_INFOFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * Filter, which PROJECT_INFO to fetch.
     * 
    **/
    where: PROJECT_INFOWhereUniqueInput
  }

  /**
   * PROJECT_INFO: findUnique
   */
  export interface PROJECT_INFOFindUniqueArgs extends PROJECT_INFOFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PROJECT_INFO base type for findFirst actions
   */
  export type PROJECT_INFOFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * Filter, which PROJECT_INFO to fetch.
     * 
    **/
    where?: PROJECT_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PROJECT_INFOS.
     * 
    **/
    cursor?: PROJECT_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_INFOS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PROJECT_INFOS.
     * 
    **/
    distinct?: Enumerable<PROJECT_INFOScalarFieldEnum>
  }

  /**
   * PROJECT_INFO: findFirst
   */
  export interface PROJECT_INFOFindFirstArgs extends PROJECT_INFOFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PROJECT_INFO findMany
   */
  export type PROJECT_INFOFindManyArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * Filter, which PROJECT_INFOS to fetch.
     * 
    **/
    where?: PROJECT_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PROJECT_INFOS.
     * 
    **/
    cursor?: PROJECT_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_INFOS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PROJECT_INFOScalarFieldEnum>
  }


  /**
   * PROJECT_INFO create
   */
  export type PROJECT_INFOCreateArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * The data needed to create a PROJECT_INFO.
     * 
    **/
    data: XOR<PROJECT_INFOCreateInput, PROJECT_INFOUncheckedCreateInput>
  }


  /**
   * PROJECT_INFO createMany
   */
  export type PROJECT_INFOCreateManyArgs = {
    /**
     * The data used to create many PROJECT_INFOS.
     * 
    **/
    data: Enumerable<PROJECT_INFOCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PROJECT_INFO update
   */
  export type PROJECT_INFOUpdateArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * The data needed to update a PROJECT_INFO.
     * 
    **/
    data: XOR<PROJECT_INFOUpdateInput, PROJECT_INFOUncheckedUpdateInput>
    /**
     * Choose, which PROJECT_INFO to update.
     * 
    **/
    where: PROJECT_INFOWhereUniqueInput
  }


  /**
   * PROJECT_INFO updateMany
   */
  export type PROJECT_INFOUpdateManyArgs = {
    /**
     * The data used to update PROJECT_INFOS.
     * 
    **/
    data: XOR<PROJECT_INFOUpdateManyMutationInput, PROJECT_INFOUncheckedUpdateManyInput>
    /**
     * Filter which PROJECT_INFOS to update
     * 
    **/
    where?: PROJECT_INFOWhereInput
  }


  /**
   * PROJECT_INFO upsert
   */
  export type PROJECT_INFOUpsertArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * The filter to search for the PROJECT_INFO to update in case it exists.
     * 
    **/
    where: PROJECT_INFOWhereUniqueInput
    /**
     * In case the PROJECT_INFO found by the `where` argument doesn't exist, create a new PROJECT_INFO with this data.
     * 
    **/
    create: XOR<PROJECT_INFOCreateInput, PROJECT_INFOUncheckedCreateInput>
    /**
     * In case the PROJECT_INFO was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PROJECT_INFOUpdateInput, PROJECT_INFOUncheckedUpdateInput>
  }


  /**
   * PROJECT_INFO delete
   */
  export type PROJECT_INFODeleteArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
    /**
     * Filter which PROJECT_INFO to delete.
     * 
    **/
    where: PROJECT_INFOWhereUniqueInput
  }


  /**
   * PROJECT_INFO deleteMany
   */
  export type PROJECT_INFODeleteManyArgs = {
    /**
     * Filter which PROJECT_INFOS to delete
     * 
    **/
    where?: PROJECT_INFOWhereInput
  }


  /**
   * PROJECT_INFO: findUniqueOrThrow
   */
  export type PROJECT_INFOFindUniqueOrThrowArgs = PROJECT_INFOFindUniqueArgsBase
      

  /**
   * PROJECT_INFO: findFirstOrThrow
   */
  export type PROJECT_INFOFindFirstOrThrowArgs = PROJECT_INFOFindFirstArgsBase
      

  /**
   * PROJECT_INFO without action
   */
  export type PROJECT_INFOArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_INFO
     * 
    **/
    select?: PROJECT_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_INFOInclude | null
  }



  /**
   * Model PROJECT_MEMBER
   */


  export type AggregatePROJECT_MEMBER = {
    _count: PROJECT_MEMBERCountAggregateOutputType | null
    _avg: PROJECT_MEMBERAvgAggregateOutputType | null
    _sum: PROJECT_MEMBERSumAggregateOutputType | null
    _min: PROJECT_MEMBERMinAggregateOutputType | null
    _max: PROJECT_MEMBERMaxAggregateOutputType | null
  }

  export type PROJECT_MEMBERAvgAggregateOutputType = {
    PJ_ID: number | null
    MEM_ID: number | null
    MEM_POS: number | null
  }

  export type PROJECT_MEMBERSumAggregateOutputType = {
    PJ_ID: bigint | null
    MEM_ID: bigint | null
    MEM_POS: bigint | null
  }

  export type PROJECT_MEMBERMinAggregateOutputType = {
    PJ_ID: bigint | null
    MEM_ID: bigint | null
    MEM_POS: bigint | null
  }

  export type PROJECT_MEMBERMaxAggregateOutputType = {
    PJ_ID: bigint | null
    MEM_ID: bigint | null
    MEM_POS: bigint | null
  }

  export type PROJECT_MEMBERCountAggregateOutputType = {
    PJ_ID: number
    MEM_ID: number
    MEM_POS: number
    _all: number
  }


  export type PROJECT_MEMBERAvgAggregateInputType = {
    PJ_ID?: true
    MEM_ID?: true
    MEM_POS?: true
  }

  export type PROJECT_MEMBERSumAggregateInputType = {
    PJ_ID?: true
    MEM_ID?: true
    MEM_POS?: true
  }

  export type PROJECT_MEMBERMinAggregateInputType = {
    PJ_ID?: true
    MEM_ID?: true
    MEM_POS?: true
  }

  export type PROJECT_MEMBERMaxAggregateInputType = {
    PJ_ID?: true
    MEM_ID?: true
    MEM_POS?: true
  }

  export type PROJECT_MEMBERCountAggregateInputType = {
    PJ_ID?: true
    MEM_ID?: true
    MEM_POS?: true
    _all?: true
  }

  export type PROJECT_MEMBERAggregateArgs = {
    /**
     * Filter which PROJECT_MEMBER to aggregate.
     * 
    **/
    where?: PROJECT_MEMBERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_MEMBERS to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_MEMBEROrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PROJECT_MEMBERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_MEMBERS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_MEMBERS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PROJECT_MEMBERS
    **/
    _count?: true | PROJECT_MEMBERCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PROJECT_MEMBERAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PROJECT_MEMBERSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PROJECT_MEMBERMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PROJECT_MEMBERMaxAggregateInputType
  }

  export type GetPROJECT_MEMBERAggregateType<T extends PROJECT_MEMBERAggregateArgs> = {
        [P in keyof T & keyof AggregatePROJECT_MEMBER]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePROJECT_MEMBER[P]>
      : GetScalarType<T[P], AggregatePROJECT_MEMBER[P]>
  }




  export type PROJECT_MEMBERGroupByArgs = {
    where?: PROJECT_MEMBERWhereInput
    orderBy?: Enumerable<PROJECT_MEMBEROrderByWithAggregationInput>
    by: Array<PROJECT_MEMBERScalarFieldEnum>
    having?: PROJECT_MEMBERScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PROJECT_MEMBERCountAggregateInputType | true
    _avg?: PROJECT_MEMBERAvgAggregateInputType
    _sum?: PROJECT_MEMBERSumAggregateInputType
    _min?: PROJECT_MEMBERMinAggregateInputType
    _max?: PROJECT_MEMBERMaxAggregateInputType
  }


  export type PROJECT_MEMBERGroupByOutputType = {
    PJ_ID: bigint
    MEM_ID: bigint
    MEM_POS: bigint | null
    _count: PROJECT_MEMBERCountAggregateOutputType | null
    _avg: PROJECT_MEMBERAvgAggregateOutputType | null
    _sum: PROJECT_MEMBERSumAggregateOutputType | null
    _min: PROJECT_MEMBERMinAggregateOutputType | null
    _max: PROJECT_MEMBERMaxAggregateOutputType | null
  }

  type GetPROJECT_MEMBERGroupByPayload<T extends PROJECT_MEMBERGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PROJECT_MEMBERGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PROJECT_MEMBERGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PROJECT_MEMBERGroupByOutputType[P]>
            : GetScalarType<T[P], PROJECT_MEMBERGroupByOutputType[P]>
        }
      >
    >


  export type PROJECT_MEMBERSelect = {
    PJ_ID?: boolean
    MEM_ID?: boolean
    MEM_POS?: boolean
    USER_INFO?: boolean | USER_INFOArgs
    PROJECT_ACCESSIBILITY?: boolean | PROJECT_ACCESSIBILITYArgs
    TASK_ACCESSIBILITY?: boolean | TASK_ACCESSIBILITYArgs
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: boolean | PROJECT_INFOArgs
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: boolean | PROJECT_INFOFindManyArgs
    TASK_INFO?: boolean | TASK_INFOFindManyArgs
    TASK_RESPONDSIPLE?: boolean | TASK_RESPONDSIPLEFindManyArgs
    _count?: boolean | PROJECT_MEMBERCountOutputTypeArgs
  }

  export type PROJECT_MEMBERInclude = {
    USER_INFO?: boolean | USER_INFOArgs
    PROJECT_ACCESSIBILITY?: boolean | PROJECT_ACCESSIBILITYArgs
    TASK_ACCESSIBILITY?: boolean | TASK_ACCESSIBILITYArgs
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: boolean | PROJECT_INFOArgs
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: boolean | PROJECT_INFOFindManyArgs
    TASK_INFO?: boolean | TASK_INFOFindManyArgs
    TASK_RESPONDSIPLE?: boolean | TASK_RESPONDSIPLEFindManyArgs
    _count?: boolean | PROJECT_MEMBERCountOutputTypeArgs
  }

  export type PROJECT_MEMBERGetPayload<
    S extends boolean | null | undefined | PROJECT_MEMBERArgs,
    U = keyof S
      > = S extends true
        ? PROJECT_MEMBER
    : S extends undefined
    ? never
    : S extends PROJECT_MEMBERArgs | PROJECT_MEMBERFindManyArgs
    ?'include' extends U
    ? PROJECT_MEMBER  & {
    [P in TrueKeys<S['include']>]:
        P extends 'USER_INFO' ? USER_INFOGetPayload<S['include'][P]> :
        P extends 'PROJECT_ACCESSIBILITY' ? PROJECT_ACCESSIBILITYGetPayload<S['include'][P]> | null :
        P extends 'TASK_ACCESSIBILITY' ? TASK_ACCESSIBILITYGetPayload<S['include'][P]> | null :
        P extends 'PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID' ? PROJECT_INFOGetPayload<S['include'][P]> :
        P extends 'PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER' ? Array < PROJECT_INFOGetPayload<S['include'][P]>>  :
        P extends 'TASK_INFO' ? Array < TASK_INFOGetPayload<S['include'][P]>>  :
        P extends 'TASK_RESPONDSIPLE' ? Array < TASK_RESPONDSIPLEGetPayload<S['include'][P]>>  :
        P extends '_count' ? PROJECT_MEMBERCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'USER_INFO' ? USER_INFOGetPayload<S['select'][P]> :
        P extends 'PROJECT_ACCESSIBILITY' ? PROJECT_ACCESSIBILITYGetPayload<S['select'][P]> | null :
        P extends 'TASK_ACCESSIBILITY' ? TASK_ACCESSIBILITYGetPayload<S['select'][P]> | null :
        P extends 'PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID' ? PROJECT_INFOGetPayload<S['select'][P]> :
        P extends 'PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER' ? Array < PROJECT_INFOGetPayload<S['select'][P]>>  :
        P extends 'TASK_INFO' ? Array < TASK_INFOGetPayload<S['select'][P]>>  :
        P extends 'TASK_RESPONDSIPLE' ? Array < TASK_RESPONDSIPLEGetPayload<S['select'][P]>>  :
        P extends '_count' ? PROJECT_MEMBERCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof PROJECT_MEMBER ? PROJECT_MEMBER[P] : never
  } 
    : PROJECT_MEMBER
  : PROJECT_MEMBER


  type PROJECT_MEMBERCountArgs = Merge<
    Omit<PROJECT_MEMBERFindManyArgs, 'select' | 'include'> & {
      select?: PROJECT_MEMBERCountAggregateInputType | true
    }
  >

  export interface PROJECT_MEMBERDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PROJECT_MEMBER that matches the filter.
     * @param {PROJECT_MEMBERFindUniqueArgs} args - Arguments to find a PROJECT_MEMBER
     * @example
     * // Get one PROJECT_MEMBER
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PROJECT_MEMBERFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PROJECT_MEMBERFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PROJECT_MEMBER'> extends True ? CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>> : CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER | null >, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T> | null >>

    /**
     * Find the first PROJECT_MEMBER that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERFindFirstArgs} args - Arguments to find a PROJECT_MEMBER
     * @example
     * // Get one PROJECT_MEMBER
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PROJECT_MEMBERFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PROJECT_MEMBERFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PROJECT_MEMBER'> extends True ? CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>> : CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER | null >, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T> | null >>

    /**
     * Find zero or more PROJECT_MEMBERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PROJECT_MEMBERS
     * const pROJECT_MEMBERS = await prisma.pROJECT_MEMBER.findMany()
     * 
     * // Get first 10 PROJECT_MEMBERS
     * const pROJECT_MEMBERS = await prisma.pROJECT_MEMBER.findMany({ take: 10 })
     * 
     * // Only select the `PJ_ID`
     * const pROJECT_MEMBERWithPJ_IDOnly = await prisma.pROJECT_MEMBER.findMany({ select: { PJ_ID: true } })
     * 
    **/
    findMany<T extends PROJECT_MEMBERFindManyArgs>(
      args?: SelectSubset<T, PROJECT_MEMBERFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PROJECT_MEMBER>>, PrismaPromise<Array<PROJECT_MEMBERGetPayload<T>>>>

    /**
     * Create a PROJECT_MEMBER.
     * @param {PROJECT_MEMBERCreateArgs} args - Arguments to create a PROJECT_MEMBER.
     * @example
     * // Create one PROJECT_MEMBER
     * const PROJECT_MEMBER = await prisma.pROJECT_MEMBER.create({
     *   data: {
     *     // ... data to create a PROJECT_MEMBER
     *   }
     * })
     * 
    **/
    create<T extends PROJECT_MEMBERCreateArgs>(
      args: SelectSubset<T, PROJECT_MEMBERCreateArgs>
    ): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>>

    /**
     * Create many PROJECT_MEMBERS.
     *     @param {PROJECT_MEMBERCreateManyArgs} args - Arguments to create many PROJECT_MEMBERS.
     *     @example
     *     // Create many PROJECT_MEMBERS
     *     const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PROJECT_MEMBERCreateManyArgs>(
      args?: SelectSubset<T, PROJECT_MEMBERCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PROJECT_MEMBER.
     * @param {PROJECT_MEMBERDeleteArgs} args - Arguments to delete one PROJECT_MEMBER.
     * @example
     * // Delete one PROJECT_MEMBER
     * const PROJECT_MEMBER = await prisma.pROJECT_MEMBER.delete({
     *   where: {
     *     // ... filter to delete one PROJECT_MEMBER
     *   }
     * })
     * 
    **/
    delete<T extends PROJECT_MEMBERDeleteArgs>(
      args: SelectSubset<T, PROJECT_MEMBERDeleteArgs>
    ): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>>

    /**
     * Update one PROJECT_MEMBER.
     * @param {PROJECT_MEMBERUpdateArgs} args - Arguments to update one PROJECT_MEMBER.
     * @example
     * // Update one PROJECT_MEMBER
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PROJECT_MEMBERUpdateArgs>(
      args: SelectSubset<T, PROJECT_MEMBERUpdateArgs>
    ): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>>

    /**
     * Delete zero or more PROJECT_MEMBERS.
     * @param {PROJECT_MEMBERDeleteManyArgs} args - Arguments to filter PROJECT_MEMBERS to delete.
     * @example
     * // Delete a few PROJECT_MEMBERS
     * const { count } = await prisma.pROJECT_MEMBER.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PROJECT_MEMBERDeleteManyArgs>(
      args?: SelectSubset<T, PROJECT_MEMBERDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PROJECT_MEMBERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PROJECT_MEMBERS
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PROJECT_MEMBERUpdateManyArgs>(
      args: SelectSubset<T, PROJECT_MEMBERUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PROJECT_MEMBER.
     * @param {PROJECT_MEMBERUpsertArgs} args - Arguments to update or create a PROJECT_MEMBER.
     * @example
     * // Update or create a PROJECT_MEMBER
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.upsert({
     *   create: {
     *     // ... data to create a PROJECT_MEMBER
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PROJECT_MEMBER we want to update
     *   }
     * })
    **/
    upsert<T extends PROJECT_MEMBERUpsertArgs>(
      args: SelectSubset<T, PROJECT_MEMBERUpsertArgs>
    ): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>>

    /**
     * Find one PROJECT_MEMBER that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {PROJECT_MEMBERFindUniqueOrThrowArgs} args - Arguments to find a PROJECT_MEMBER
     * @example
     * // Get one PROJECT_MEMBER
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PROJECT_MEMBERFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PROJECT_MEMBERFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>>

    /**
     * Find the first PROJECT_MEMBER that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERFindFirstOrThrowArgs} args - Arguments to find a PROJECT_MEMBER
     * @example
     * // Get one PROJECT_MEMBER
     * const pROJECT_MEMBER = await prisma.pROJECT_MEMBER.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PROJECT_MEMBERFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PROJECT_MEMBERFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER>, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T>>>

    /**
     * Count the number of PROJECT_MEMBERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERCountArgs} args - Arguments to filter PROJECT_MEMBERS to count.
     * @example
     * // Count the number of PROJECT_MEMBERS
     * const count = await prisma.pROJECT_MEMBER.count({
     *   where: {
     *     // ... the filter for the PROJECT_MEMBERS we want to count
     *   }
     * })
    **/
    count<T extends PROJECT_MEMBERCountArgs>(
      args?: Subset<T, PROJECT_MEMBERCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PROJECT_MEMBERCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PROJECT_MEMBER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PROJECT_MEMBERAggregateArgs>(args: Subset<T, PROJECT_MEMBERAggregateArgs>): PrismaPromise<GetPROJECT_MEMBERAggregateType<T>>

    /**
     * Group by PROJECT_MEMBER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PROJECT_MEMBERGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PROJECT_MEMBERGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PROJECT_MEMBERGroupByArgs['orderBy'] }
        : { orderBy?: PROJECT_MEMBERGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PROJECT_MEMBERGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPROJECT_MEMBERGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PROJECT_MEMBER.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PROJECT_MEMBERClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    USER_INFO<T extends USER_INFOArgs = {}>(args?: Subset<T, USER_INFOArgs>): CheckSelect<T, Prisma__USER_INFOClient<USER_INFO | null >, Prisma__USER_INFOClient<USER_INFOGetPayload<T> | null >>;

    PROJECT_ACCESSIBILITY<T extends PROJECT_ACCESSIBILITYArgs = {}>(args?: Subset<T, PROJECT_ACCESSIBILITYArgs>): CheckSelect<T, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITY | null >, Prisma__PROJECT_ACCESSIBILITYClient<PROJECT_ACCESSIBILITYGetPayload<T> | null >>;

    TASK_ACCESSIBILITY<T extends TASK_ACCESSIBILITYArgs = {}>(args?: Subset<T, TASK_ACCESSIBILITYArgs>): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY | null >, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T> | null >>;

    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID<T extends PROJECT_INFOArgs = {}>(args?: Subset<T, PROJECT_INFOArgs>): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO | null >, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T> | null >>;

    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER<T extends PROJECT_INFOFindManyArgs = {}>(args?: Subset<T, PROJECT_INFOFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PROJECT_INFO>>, PrismaPromise<Array<PROJECT_INFOGetPayload<T>>>>;

    TASK_INFO<T extends TASK_INFOFindManyArgs = {}>(args?: Subset<T, TASK_INFOFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TASK_INFO>>, PrismaPromise<Array<TASK_INFOGetPayload<T>>>>;

    TASK_RESPONDSIPLE<T extends TASK_RESPONDSIPLEFindManyArgs = {}>(args?: Subset<T, TASK_RESPONDSIPLEFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TASK_RESPONDSIPLE>>, PrismaPromise<Array<TASK_RESPONDSIPLEGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PROJECT_MEMBER base type for findUnique actions
   */
  export type PROJECT_MEMBERFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * Filter, which PROJECT_MEMBER to fetch.
     * 
    **/
    where: PROJECT_MEMBERWhereUniqueInput
  }

  /**
   * PROJECT_MEMBER: findUnique
   */
  export interface PROJECT_MEMBERFindUniqueArgs extends PROJECT_MEMBERFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PROJECT_MEMBER base type for findFirst actions
   */
  export type PROJECT_MEMBERFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * Filter, which PROJECT_MEMBER to fetch.
     * 
    **/
    where?: PROJECT_MEMBERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_MEMBERS to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_MEMBEROrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PROJECT_MEMBERS.
     * 
    **/
    cursor?: PROJECT_MEMBERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_MEMBERS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_MEMBERS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PROJECT_MEMBERS.
     * 
    **/
    distinct?: Enumerable<PROJECT_MEMBERScalarFieldEnum>
  }

  /**
   * PROJECT_MEMBER: findFirst
   */
  export interface PROJECT_MEMBERFindFirstArgs extends PROJECT_MEMBERFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PROJECT_MEMBER findMany
   */
  export type PROJECT_MEMBERFindManyArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * Filter, which PROJECT_MEMBERS to fetch.
     * 
    **/
    where?: PROJECT_MEMBERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PROJECT_MEMBERS to fetch.
     * 
    **/
    orderBy?: Enumerable<PROJECT_MEMBEROrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PROJECT_MEMBERS.
     * 
    **/
    cursor?: PROJECT_MEMBERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PROJECT_MEMBERS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PROJECT_MEMBERS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PROJECT_MEMBERScalarFieldEnum>
  }


  /**
   * PROJECT_MEMBER create
   */
  export type PROJECT_MEMBERCreateArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * The data needed to create a PROJECT_MEMBER.
     * 
    **/
    data: XOR<PROJECT_MEMBERCreateInput, PROJECT_MEMBERUncheckedCreateInput>
  }


  /**
   * PROJECT_MEMBER createMany
   */
  export type PROJECT_MEMBERCreateManyArgs = {
    /**
     * The data used to create many PROJECT_MEMBERS.
     * 
    **/
    data: Enumerable<PROJECT_MEMBERCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PROJECT_MEMBER update
   */
  export type PROJECT_MEMBERUpdateArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * The data needed to update a PROJECT_MEMBER.
     * 
    **/
    data: XOR<PROJECT_MEMBERUpdateInput, PROJECT_MEMBERUncheckedUpdateInput>
    /**
     * Choose, which PROJECT_MEMBER to update.
     * 
    **/
    where: PROJECT_MEMBERWhereUniqueInput
  }


  /**
   * PROJECT_MEMBER updateMany
   */
  export type PROJECT_MEMBERUpdateManyArgs = {
    /**
     * The data used to update PROJECT_MEMBERS.
     * 
    **/
    data: XOR<PROJECT_MEMBERUpdateManyMutationInput, PROJECT_MEMBERUncheckedUpdateManyInput>
    /**
     * Filter which PROJECT_MEMBERS to update
     * 
    **/
    where?: PROJECT_MEMBERWhereInput
  }


  /**
   * PROJECT_MEMBER upsert
   */
  export type PROJECT_MEMBERUpsertArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * The filter to search for the PROJECT_MEMBER to update in case it exists.
     * 
    **/
    where: PROJECT_MEMBERWhereUniqueInput
    /**
     * In case the PROJECT_MEMBER found by the `where` argument doesn't exist, create a new PROJECT_MEMBER with this data.
     * 
    **/
    create: XOR<PROJECT_MEMBERCreateInput, PROJECT_MEMBERUncheckedCreateInput>
    /**
     * In case the PROJECT_MEMBER was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PROJECT_MEMBERUpdateInput, PROJECT_MEMBERUncheckedUpdateInput>
  }


  /**
   * PROJECT_MEMBER delete
   */
  export type PROJECT_MEMBERDeleteArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
    /**
     * Filter which PROJECT_MEMBER to delete.
     * 
    **/
    where: PROJECT_MEMBERWhereUniqueInput
  }


  /**
   * PROJECT_MEMBER deleteMany
   */
  export type PROJECT_MEMBERDeleteManyArgs = {
    /**
     * Filter which PROJECT_MEMBERS to delete
     * 
    **/
    where?: PROJECT_MEMBERWhereInput
  }


  /**
   * PROJECT_MEMBER: findUniqueOrThrow
   */
  export type PROJECT_MEMBERFindUniqueOrThrowArgs = PROJECT_MEMBERFindUniqueArgsBase
      

  /**
   * PROJECT_MEMBER: findFirstOrThrow
   */
  export type PROJECT_MEMBERFindFirstOrThrowArgs = PROJECT_MEMBERFindFirstArgsBase
      

  /**
   * PROJECT_MEMBER without action
   */
  export type PROJECT_MEMBERArgs = {
    /**
     * Select specific fields to fetch from the PROJECT_MEMBER
     * 
    **/
    select?: PROJECT_MEMBERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PROJECT_MEMBERInclude | null
  }



  /**
   * Model TASK_ACCESSIBILITY
   */


  export type AggregateTASK_ACCESSIBILITY = {
    _count: TASK_ACCESSIBILITYCountAggregateOutputType | null
    _avg: TASK_ACCESSIBILITYAvgAggregateOutputType | null
    _sum: TASK_ACCESSIBILITYSumAggregateOutputType | null
    _min: TASK_ACCESSIBILITYMinAggregateOutputType | null
    _max: TASK_ACCESSIBILITYMaxAggregateOutputType | null
  }

  export type TASK_ACCESSIBILITYAvgAggregateOutputType = {
    MEM_POS: number | null
  }

  export type TASK_ACCESSIBILITYSumAggregateOutputType = {
    MEM_POS: bigint | null
  }

  export type TASK_ACCESSIBILITYMinAggregateOutputType = {
    MEM_POS: bigint | null
    EDIT_MEM: string | null
    ADD_TASK: string | null
    DEL_TASK: string | null
    EDIT_NAME: string | null
    EDIT_DEADLINE: string | null
    EDIT_STATUS: string | null
    EDIT_DESCRIPTION: string | null
  }

  export type TASK_ACCESSIBILITYMaxAggregateOutputType = {
    MEM_POS: bigint | null
    EDIT_MEM: string | null
    ADD_TASK: string | null
    DEL_TASK: string | null
    EDIT_NAME: string | null
    EDIT_DEADLINE: string | null
    EDIT_STATUS: string | null
    EDIT_DESCRIPTION: string | null
  }

  export type TASK_ACCESSIBILITYCountAggregateOutputType = {
    MEM_POS: number
    EDIT_MEM: number
    ADD_TASK: number
    DEL_TASK: number
    EDIT_NAME: number
    EDIT_DEADLINE: number
    EDIT_STATUS: number
    EDIT_DESCRIPTION: number
    _all: number
  }


  export type TASK_ACCESSIBILITYAvgAggregateInputType = {
    MEM_POS?: true
  }

  export type TASK_ACCESSIBILITYSumAggregateInputType = {
    MEM_POS?: true
  }

  export type TASK_ACCESSIBILITYMinAggregateInputType = {
    MEM_POS?: true
    EDIT_MEM?: true
    ADD_TASK?: true
    DEL_TASK?: true
    EDIT_NAME?: true
    EDIT_DEADLINE?: true
    EDIT_STATUS?: true
    EDIT_DESCRIPTION?: true
  }

  export type TASK_ACCESSIBILITYMaxAggregateInputType = {
    MEM_POS?: true
    EDIT_MEM?: true
    ADD_TASK?: true
    DEL_TASK?: true
    EDIT_NAME?: true
    EDIT_DEADLINE?: true
    EDIT_STATUS?: true
    EDIT_DESCRIPTION?: true
  }

  export type TASK_ACCESSIBILITYCountAggregateInputType = {
    MEM_POS?: true
    EDIT_MEM?: true
    ADD_TASK?: true
    DEL_TASK?: true
    EDIT_NAME?: true
    EDIT_DEADLINE?: true
    EDIT_STATUS?: true
    EDIT_DESCRIPTION?: true
    _all?: true
  }

  export type TASK_ACCESSIBILITYAggregateArgs = {
    /**
     * Filter which TASK_ACCESSIBILITY to aggregate.
     * 
    **/
    where?: TASK_ACCESSIBILITYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_ACCESSIBILITIES to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_ACCESSIBILITYOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TASK_ACCESSIBILITYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_ACCESSIBILITIES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_ACCESSIBILITIES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TASK_ACCESSIBILITIES
    **/
    _count?: true | TASK_ACCESSIBILITYCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TASK_ACCESSIBILITYAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TASK_ACCESSIBILITYSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TASK_ACCESSIBILITYMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TASK_ACCESSIBILITYMaxAggregateInputType
  }

  export type GetTASK_ACCESSIBILITYAggregateType<T extends TASK_ACCESSIBILITYAggregateArgs> = {
        [P in keyof T & keyof AggregateTASK_ACCESSIBILITY]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTASK_ACCESSIBILITY[P]>
      : GetScalarType<T[P], AggregateTASK_ACCESSIBILITY[P]>
  }




  export type TASK_ACCESSIBILITYGroupByArgs = {
    where?: TASK_ACCESSIBILITYWhereInput
    orderBy?: Enumerable<TASK_ACCESSIBILITYOrderByWithAggregationInput>
    by: Array<TASK_ACCESSIBILITYScalarFieldEnum>
    having?: TASK_ACCESSIBILITYScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TASK_ACCESSIBILITYCountAggregateInputType | true
    _avg?: TASK_ACCESSIBILITYAvgAggregateInputType
    _sum?: TASK_ACCESSIBILITYSumAggregateInputType
    _min?: TASK_ACCESSIBILITYMinAggregateInputType
    _max?: TASK_ACCESSIBILITYMaxAggregateInputType
  }


  export type TASK_ACCESSIBILITYGroupByOutputType = {
    MEM_POS: bigint
    EDIT_MEM: string | null
    ADD_TASK: string | null
    DEL_TASK: string | null
    EDIT_NAME: string | null
    EDIT_DEADLINE: string | null
    EDIT_STATUS: string | null
    EDIT_DESCRIPTION: string | null
    _count: TASK_ACCESSIBILITYCountAggregateOutputType | null
    _avg: TASK_ACCESSIBILITYAvgAggregateOutputType | null
    _sum: TASK_ACCESSIBILITYSumAggregateOutputType | null
    _min: TASK_ACCESSIBILITYMinAggregateOutputType | null
    _max: TASK_ACCESSIBILITYMaxAggregateOutputType | null
  }

  type GetTASK_ACCESSIBILITYGroupByPayload<T extends TASK_ACCESSIBILITYGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TASK_ACCESSIBILITYGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TASK_ACCESSIBILITYGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TASK_ACCESSIBILITYGroupByOutputType[P]>
            : GetScalarType<T[P], TASK_ACCESSIBILITYGroupByOutputType[P]>
        }
      >
    >


  export type TASK_ACCESSIBILITYSelect = {
    MEM_POS?: boolean
    EDIT_MEM?: boolean
    ADD_TASK?: boolean
    DEL_TASK?: boolean
    EDIT_NAME?: boolean
    EDIT_DEADLINE?: boolean
    EDIT_STATUS?: boolean
    EDIT_DESCRIPTION?: boolean
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERFindManyArgs
    _count?: boolean | TASK_ACCESSIBILITYCountOutputTypeArgs
  }

  export type TASK_ACCESSIBILITYInclude = {
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERFindManyArgs
    _count?: boolean | TASK_ACCESSIBILITYCountOutputTypeArgs
  }

  export type TASK_ACCESSIBILITYGetPayload<
    S extends boolean | null | undefined | TASK_ACCESSIBILITYArgs,
    U = keyof S
      > = S extends true
        ? TASK_ACCESSIBILITY
    : S extends undefined
    ? never
    : S extends TASK_ACCESSIBILITYArgs | TASK_ACCESSIBILITYFindManyArgs
    ?'include' extends U
    ? TASK_ACCESSIBILITY  & {
    [P in TrueKeys<S['include']>]:
        P extends 'PROJECT_MEMBER' ? Array < PROJECT_MEMBERGetPayload<S['include'][P]>>  :
        P extends '_count' ? TASK_ACCESSIBILITYCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'PROJECT_MEMBER' ? Array < PROJECT_MEMBERGetPayload<S['select'][P]>>  :
        P extends '_count' ? TASK_ACCESSIBILITYCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TASK_ACCESSIBILITY ? TASK_ACCESSIBILITY[P] : never
  } 
    : TASK_ACCESSIBILITY
  : TASK_ACCESSIBILITY


  type TASK_ACCESSIBILITYCountArgs = Merge<
    Omit<TASK_ACCESSIBILITYFindManyArgs, 'select' | 'include'> & {
      select?: TASK_ACCESSIBILITYCountAggregateInputType | true
    }
  >

  export interface TASK_ACCESSIBILITYDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TASK_ACCESSIBILITY that matches the filter.
     * @param {TASK_ACCESSIBILITYFindUniqueArgs} args - Arguments to find a TASK_ACCESSIBILITY
     * @example
     * // Get one TASK_ACCESSIBILITY
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TASK_ACCESSIBILITYFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TASK_ACCESSIBILITYFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TASK_ACCESSIBILITY'> extends True ? CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>> : CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY | null >, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T> | null >>

    /**
     * Find the first TASK_ACCESSIBILITY that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYFindFirstArgs} args - Arguments to find a TASK_ACCESSIBILITY
     * @example
     * // Get one TASK_ACCESSIBILITY
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TASK_ACCESSIBILITYFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TASK_ACCESSIBILITYFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TASK_ACCESSIBILITY'> extends True ? CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>> : CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY | null >, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T> | null >>

    /**
     * Find zero or more TASK_ACCESSIBILITIES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TASK_ACCESSIBILITIES
     * const tASK_ACCESSIBILITIES = await prisma.tASK_ACCESSIBILITY.findMany()
     * 
     * // Get first 10 TASK_ACCESSIBILITIES
     * const tASK_ACCESSIBILITIES = await prisma.tASK_ACCESSIBILITY.findMany({ take: 10 })
     * 
     * // Only select the `MEM_POS`
     * const tASK_ACCESSIBILITYWithMEM_POSOnly = await prisma.tASK_ACCESSIBILITY.findMany({ select: { MEM_POS: true } })
     * 
    **/
    findMany<T extends TASK_ACCESSIBILITYFindManyArgs>(
      args?: SelectSubset<T, TASK_ACCESSIBILITYFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TASK_ACCESSIBILITY>>, PrismaPromise<Array<TASK_ACCESSIBILITYGetPayload<T>>>>

    /**
     * Create a TASK_ACCESSIBILITY.
     * @param {TASK_ACCESSIBILITYCreateArgs} args - Arguments to create a TASK_ACCESSIBILITY.
     * @example
     * // Create one TASK_ACCESSIBILITY
     * const TASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.create({
     *   data: {
     *     // ... data to create a TASK_ACCESSIBILITY
     *   }
     * })
     * 
    **/
    create<T extends TASK_ACCESSIBILITYCreateArgs>(
      args: SelectSubset<T, TASK_ACCESSIBILITYCreateArgs>
    ): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>>

    /**
     * Create many TASK_ACCESSIBILITIES.
     *     @param {TASK_ACCESSIBILITYCreateManyArgs} args - Arguments to create many TASK_ACCESSIBILITIES.
     *     @example
     *     // Create many TASK_ACCESSIBILITIES
     *     const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TASK_ACCESSIBILITYCreateManyArgs>(
      args?: SelectSubset<T, TASK_ACCESSIBILITYCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TASK_ACCESSIBILITY.
     * @param {TASK_ACCESSIBILITYDeleteArgs} args - Arguments to delete one TASK_ACCESSIBILITY.
     * @example
     * // Delete one TASK_ACCESSIBILITY
     * const TASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.delete({
     *   where: {
     *     // ... filter to delete one TASK_ACCESSIBILITY
     *   }
     * })
     * 
    **/
    delete<T extends TASK_ACCESSIBILITYDeleteArgs>(
      args: SelectSubset<T, TASK_ACCESSIBILITYDeleteArgs>
    ): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>>

    /**
     * Update one TASK_ACCESSIBILITY.
     * @param {TASK_ACCESSIBILITYUpdateArgs} args - Arguments to update one TASK_ACCESSIBILITY.
     * @example
     * // Update one TASK_ACCESSIBILITY
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TASK_ACCESSIBILITYUpdateArgs>(
      args: SelectSubset<T, TASK_ACCESSIBILITYUpdateArgs>
    ): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>>

    /**
     * Delete zero or more TASK_ACCESSIBILITIES.
     * @param {TASK_ACCESSIBILITYDeleteManyArgs} args - Arguments to filter TASK_ACCESSIBILITIES to delete.
     * @example
     * // Delete a few TASK_ACCESSIBILITIES
     * const { count } = await prisma.tASK_ACCESSIBILITY.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TASK_ACCESSIBILITYDeleteManyArgs>(
      args?: SelectSubset<T, TASK_ACCESSIBILITYDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TASK_ACCESSIBILITIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TASK_ACCESSIBILITIES
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TASK_ACCESSIBILITYUpdateManyArgs>(
      args: SelectSubset<T, TASK_ACCESSIBILITYUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TASK_ACCESSIBILITY.
     * @param {TASK_ACCESSIBILITYUpsertArgs} args - Arguments to update or create a TASK_ACCESSIBILITY.
     * @example
     * // Update or create a TASK_ACCESSIBILITY
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.upsert({
     *   create: {
     *     // ... data to create a TASK_ACCESSIBILITY
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TASK_ACCESSIBILITY we want to update
     *   }
     * })
    **/
    upsert<T extends TASK_ACCESSIBILITYUpsertArgs>(
      args: SelectSubset<T, TASK_ACCESSIBILITYUpsertArgs>
    ): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>>

    /**
     * Find one TASK_ACCESSIBILITY that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TASK_ACCESSIBILITYFindUniqueOrThrowArgs} args - Arguments to find a TASK_ACCESSIBILITY
     * @example
     * // Get one TASK_ACCESSIBILITY
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TASK_ACCESSIBILITYFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TASK_ACCESSIBILITYFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>>

    /**
     * Find the first TASK_ACCESSIBILITY that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYFindFirstOrThrowArgs} args - Arguments to find a TASK_ACCESSIBILITY
     * @example
     * // Get one TASK_ACCESSIBILITY
     * const tASK_ACCESSIBILITY = await prisma.tASK_ACCESSIBILITY.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TASK_ACCESSIBILITYFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TASK_ACCESSIBILITYFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITY>, Prisma__TASK_ACCESSIBILITYClient<TASK_ACCESSIBILITYGetPayload<T>>>

    /**
     * Count the number of TASK_ACCESSIBILITIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYCountArgs} args - Arguments to filter TASK_ACCESSIBILITIES to count.
     * @example
     * // Count the number of TASK_ACCESSIBILITIES
     * const count = await prisma.tASK_ACCESSIBILITY.count({
     *   where: {
     *     // ... the filter for the TASK_ACCESSIBILITIES we want to count
     *   }
     * })
    **/
    count<T extends TASK_ACCESSIBILITYCountArgs>(
      args?: Subset<T, TASK_ACCESSIBILITYCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TASK_ACCESSIBILITYCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TASK_ACCESSIBILITY.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TASK_ACCESSIBILITYAggregateArgs>(args: Subset<T, TASK_ACCESSIBILITYAggregateArgs>): PrismaPromise<GetTASK_ACCESSIBILITYAggregateType<T>>

    /**
     * Group by TASK_ACCESSIBILITY.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_ACCESSIBILITYGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TASK_ACCESSIBILITYGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TASK_ACCESSIBILITYGroupByArgs['orderBy'] }
        : { orderBy?: TASK_ACCESSIBILITYGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TASK_ACCESSIBILITYGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTASK_ACCESSIBILITYGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TASK_ACCESSIBILITY.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TASK_ACCESSIBILITYClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PROJECT_MEMBER<T extends PROJECT_MEMBERFindManyArgs = {}>(args?: Subset<T, PROJECT_MEMBERFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PROJECT_MEMBER>>, PrismaPromise<Array<PROJECT_MEMBERGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TASK_ACCESSIBILITY base type for findUnique actions
   */
  export type TASK_ACCESSIBILITYFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * Filter, which TASK_ACCESSIBILITY to fetch.
     * 
    **/
    where: TASK_ACCESSIBILITYWhereUniqueInput
  }

  /**
   * TASK_ACCESSIBILITY: findUnique
   */
  export interface TASK_ACCESSIBILITYFindUniqueArgs extends TASK_ACCESSIBILITYFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TASK_ACCESSIBILITY base type for findFirst actions
   */
  export type TASK_ACCESSIBILITYFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * Filter, which TASK_ACCESSIBILITY to fetch.
     * 
    **/
    where?: TASK_ACCESSIBILITYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_ACCESSIBILITIES to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_ACCESSIBILITYOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TASK_ACCESSIBILITIES.
     * 
    **/
    cursor?: TASK_ACCESSIBILITYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_ACCESSIBILITIES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_ACCESSIBILITIES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TASK_ACCESSIBILITIES.
     * 
    **/
    distinct?: Enumerable<TASK_ACCESSIBILITYScalarFieldEnum>
  }

  /**
   * TASK_ACCESSIBILITY: findFirst
   */
  export interface TASK_ACCESSIBILITYFindFirstArgs extends TASK_ACCESSIBILITYFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TASK_ACCESSIBILITY findMany
   */
  export type TASK_ACCESSIBILITYFindManyArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * Filter, which TASK_ACCESSIBILITIES to fetch.
     * 
    **/
    where?: TASK_ACCESSIBILITYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_ACCESSIBILITIES to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_ACCESSIBILITYOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TASK_ACCESSIBILITIES.
     * 
    **/
    cursor?: TASK_ACCESSIBILITYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_ACCESSIBILITIES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_ACCESSIBILITIES.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TASK_ACCESSIBILITYScalarFieldEnum>
  }


  /**
   * TASK_ACCESSIBILITY create
   */
  export type TASK_ACCESSIBILITYCreateArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * The data needed to create a TASK_ACCESSIBILITY.
     * 
    **/
    data: XOR<TASK_ACCESSIBILITYCreateInput, TASK_ACCESSIBILITYUncheckedCreateInput>
  }


  /**
   * TASK_ACCESSIBILITY createMany
   */
  export type TASK_ACCESSIBILITYCreateManyArgs = {
    /**
     * The data used to create many TASK_ACCESSIBILITIES.
     * 
    **/
    data: Enumerable<TASK_ACCESSIBILITYCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TASK_ACCESSIBILITY update
   */
  export type TASK_ACCESSIBILITYUpdateArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * The data needed to update a TASK_ACCESSIBILITY.
     * 
    **/
    data: XOR<TASK_ACCESSIBILITYUpdateInput, TASK_ACCESSIBILITYUncheckedUpdateInput>
    /**
     * Choose, which TASK_ACCESSIBILITY to update.
     * 
    **/
    where: TASK_ACCESSIBILITYWhereUniqueInput
  }


  /**
   * TASK_ACCESSIBILITY updateMany
   */
  export type TASK_ACCESSIBILITYUpdateManyArgs = {
    /**
     * The data used to update TASK_ACCESSIBILITIES.
     * 
    **/
    data: XOR<TASK_ACCESSIBILITYUpdateManyMutationInput, TASK_ACCESSIBILITYUncheckedUpdateManyInput>
    /**
     * Filter which TASK_ACCESSIBILITIES to update
     * 
    **/
    where?: TASK_ACCESSIBILITYWhereInput
  }


  /**
   * TASK_ACCESSIBILITY upsert
   */
  export type TASK_ACCESSIBILITYUpsertArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * The filter to search for the TASK_ACCESSIBILITY to update in case it exists.
     * 
    **/
    where: TASK_ACCESSIBILITYWhereUniqueInput
    /**
     * In case the TASK_ACCESSIBILITY found by the `where` argument doesn't exist, create a new TASK_ACCESSIBILITY with this data.
     * 
    **/
    create: XOR<TASK_ACCESSIBILITYCreateInput, TASK_ACCESSIBILITYUncheckedCreateInput>
    /**
     * In case the TASK_ACCESSIBILITY was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TASK_ACCESSIBILITYUpdateInput, TASK_ACCESSIBILITYUncheckedUpdateInput>
  }


  /**
   * TASK_ACCESSIBILITY delete
   */
  export type TASK_ACCESSIBILITYDeleteArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
    /**
     * Filter which TASK_ACCESSIBILITY to delete.
     * 
    **/
    where: TASK_ACCESSIBILITYWhereUniqueInput
  }


  /**
   * TASK_ACCESSIBILITY deleteMany
   */
  export type TASK_ACCESSIBILITYDeleteManyArgs = {
    /**
     * Filter which TASK_ACCESSIBILITIES to delete
     * 
    **/
    where?: TASK_ACCESSIBILITYWhereInput
  }


  /**
   * TASK_ACCESSIBILITY: findUniqueOrThrow
   */
  export type TASK_ACCESSIBILITYFindUniqueOrThrowArgs = TASK_ACCESSIBILITYFindUniqueArgsBase
      

  /**
   * TASK_ACCESSIBILITY: findFirstOrThrow
   */
  export type TASK_ACCESSIBILITYFindFirstOrThrowArgs = TASK_ACCESSIBILITYFindFirstArgsBase
      

  /**
   * TASK_ACCESSIBILITY without action
   */
  export type TASK_ACCESSIBILITYArgs = {
    /**
     * Select specific fields to fetch from the TASK_ACCESSIBILITY
     * 
    **/
    select?: TASK_ACCESSIBILITYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_ACCESSIBILITYInclude | null
  }



  /**
   * Model TASK_INFO
   */


  export type AggregateTASK_INFO = {
    _count: TASK_INFOCountAggregateOutputType | null
    _avg: TASK_INFOAvgAggregateOutputType | null
    _sum: TASK_INFOSumAggregateOutputType | null
    _min: TASK_INFOMinAggregateOutputType | null
    _max: TASK_INFOMaxAggregateOutputType | null
  }

  export type TASK_INFOAvgAggregateOutputType = {
    PJ_ID: number | null
    TASK_ID: number | null
    TASK_CREATOR: number | null
  }

  export type TASK_INFOSumAggregateOutputType = {
    PJ_ID: bigint | null
    TASK_ID: bigint | null
    TASK_CREATOR: bigint | null
  }

  export type TASK_INFOMinAggregateOutputType = {
    PJ_ID: bigint | null
    TASK_ID: bigint | null
    TASK_STATUS: string | null
    TASK_NAME: string | null
    TASK_DESCRIPTON: string | null
    TASK_CREATEDAY: Date | null
    TASK_DEADLINE: Date | null
    TASK_CREATOR: bigint | null
  }

  export type TASK_INFOMaxAggregateOutputType = {
    PJ_ID: bigint | null
    TASK_ID: bigint | null
    TASK_STATUS: string | null
    TASK_NAME: string | null
    TASK_DESCRIPTON: string | null
    TASK_CREATEDAY: Date | null
    TASK_DEADLINE: Date | null
    TASK_CREATOR: bigint | null
  }

  export type TASK_INFOCountAggregateOutputType = {
    PJ_ID: number
    TASK_ID: number
    TASK_STATUS: number
    TASK_NAME: number
    TASK_DESCRIPTON: number
    TASK_CREATEDAY: number
    TASK_DEADLINE: number
    TASK_CREATOR: number
    _all: number
  }


  export type TASK_INFOAvgAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    TASK_CREATOR?: true
  }

  export type TASK_INFOSumAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    TASK_CREATOR?: true
  }

  export type TASK_INFOMinAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    TASK_STATUS?: true
    TASK_NAME?: true
    TASK_DESCRIPTON?: true
    TASK_CREATEDAY?: true
    TASK_DEADLINE?: true
    TASK_CREATOR?: true
  }

  export type TASK_INFOMaxAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    TASK_STATUS?: true
    TASK_NAME?: true
    TASK_DESCRIPTON?: true
    TASK_CREATEDAY?: true
    TASK_DEADLINE?: true
    TASK_CREATOR?: true
  }

  export type TASK_INFOCountAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    TASK_STATUS?: true
    TASK_NAME?: true
    TASK_DESCRIPTON?: true
    TASK_CREATEDAY?: true
    TASK_DEADLINE?: true
    TASK_CREATOR?: true
    _all?: true
  }

  export type TASK_INFOAggregateArgs = {
    /**
     * Filter which TASK_INFO to aggregate.
     * 
    **/
    where?: TASK_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TASK_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_INFOS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TASK_INFOS
    **/
    _count?: true | TASK_INFOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TASK_INFOAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TASK_INFOSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TASK_INFOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TASK_INFOMaxAggregateInputType
  }

  export type GetTASK_INFOAggregateType<T extends TASK_INFOAggregateArgs> = {
        [P in keyof T & keyof AggregateTASK_INFO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTASK_INFO[P]>
      : GetScalarType<T[P], AggregateTASK_INFO[P]>
  }




  export type TASK_INFOGroupByArgs = {
    where?: TASK_INFOWhereInput
    orderBy?: Enumerable<TASK_INFOOrderByWithAggregationInput>
    by: Array<TASK_INFOScalarFieldEnum>
    having?: TASK_INFOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TASK_INFOCountAggregateInputType | true
    _avg?: TASK_INFOAvgAggregateInputType
    _sum?: TASK_INFOSumAggregateInputType
    _min?: TASK_INFOMinAggregateInputType
    _max?: TASK_INFOMaxAggregateInputType
  }


  export type TASK_INFOGroupByOutputType = {
    PJ_ID: bigint
    TASK_ID: bigint
    TASK_STATUS: string | null
    TASK_NAME: string | null
    TASK_DESCRIPTON: string | null
    TASK_CREATEDAY: Date | null
    TASK_DEADLINE: Date | null
    TASK_CREATOR: bigint | null
    _count: TASK_INFOCountAggregateOutputType | null
    _avg: TASK_INFOAvgAggregateOutputType | null
    _sum: TASK_INFOSumAggregateOutputType | null
    _min: TASK_INFOMinAggregateOutputType | null
    _max: TASK_INFOMaxAggregateOutputType | null
  }

  type GetTASK_INFOGroupByPayload<T extends TASK_INFOGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TASK_INFOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TASK_INFOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TASK_INFOGroupByOutputType[P]>
            : GetScalarType<T[P], TASK_INFOGroupByOutputType[P]>
        }
      >
    >


  export type TASK_INFOSelect = {
    PJ_ID?: boolean
    TASK_ID?: boolean
    TASK_STATUS?: boolean
    TASK_NAME?: boolean
    TASK_DESCRIPTON?: boolean
    TASK_CREATEDAY?: boolean
    TASK_DEADLINE?: boolean
    TASK_CREATOR?: boolean
    PROJECT_INFO?: boolean | PROJECT_INFOArgs
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERArgs
    TASK_RESPONDSIPLE?: boolean | TASK_RESPONDSIPLEFindManyArgs
    _count?: boolean | TASK_INFOCountOutputTypeArgs
  }

  export type TASK_INFOInclude = {
    PROJECT_INFO?: boolean | PROJECT_INFOArgs
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERArgs
    TASK_RESPONDSIPLE?: boolean | TASK_RESPONDSIPLEFindManyArgs
    _count?: boolean | TASK_INFOCountOutputTypeArgs
  }

  export type TASK_INFOGetPayload<
    S extends boolean | null | undefined | TASK_INFOArgs,
    U = keyof S
      > = S extends true
        ? TASK_INFO
    : S extends undefined
    ? never
    : S extends TASK_INFOArgs | TASK_INFOFindManyArgs
    ?'include' extends U
    ? TASK_INFO  & {
    [P in TrueKeys<S['include']>]:
        P extends 'PROJECT_INFO' ? PROJECT_INFOGetPayload<S['include'][P]> :
        P extends 'PROJECT_MEMBER' ? PROJECT_MEMBERGetPayload<S['include'][P]> | null :
        P extends 'TASK_RESPONDSIPLE' ? Array < TASK_RESPONDSIPLEGetPayload<S['include'][P]>>  :
        P extends '_count' ? TASK_INFOCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'PROJECT_INFO' ? PROJECT_INFOGetPayload<S['select'][P]> :
        P extends 'PROJECT_MEMBER' ? PROJECT_MEMBERGetPayload<S['select'][P]> | null :
        P extends 'TASK_RESPONDSIPLE' ? Array < TASK_RESPONDSIPLEGetPayload<S['select'][P]>>  :
        P extends '_count' ? TASK_INFOCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TASK_INFO ? TASK_INFO[P] : never
  } 
    : TASK_INFO
  : TASK_INFO


  type TASK_INFOCountArgs = Merge<
    Omit<TASK_INFOFindManyArgs, 'select' | 'include'> & {
      select?: TASK_INFOCountAggregateInputType | true
    }
  >

  export interface TASK_INFODelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TASK_INFO that matches the filter.
     * @param {TASK_INFOFindUniqueArgs} args - Arguments to find a TASK_INFO
     * @example
     * // Get one TASK_INFO
     * const tASK_INFO = await prisma.tASK_INFO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TASK_INFOFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TASK_INFOFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TASK_INFO'> extends True ? CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>> : CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO | null >, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T> | null >>

    /**
     * Find the first TASK_INFO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOFindFirstArgs} args - Arguments to find a TASK_INFO
     * @example
     * // Get one TASK_INFO
     * const tASK_INFO = await prisma.tASK_INFO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TASK_INFOFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TASK_INFOFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TASK_INFO'> extends True ? CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>> : CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO | null >, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T> | null >>

    /**
     * Find zero or more TASK_INFOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TASK_INFOS
     * const tASK_INFOS = await prisma.tASK_INFO.findMany()
     * 
     * // Get first 10 TASK_INFOS
     * const tASK_INFOS = await prisma.tASK_INFO.findMany({ take: 10 })
     * 
     * // Only select the `PJ_ID`
     * const tASK_INFOWithPJ_IDOnly = await prisma.tASK_INFO.findMany({ select: { PJ_ID: true } })
     * 
    **/
    findMany<T extends TASK_INFOFindManyArgs>(
      args?: SelectSubset<T, TASK_INFOFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TASK_INFO>>, PrismaPromise<Array<TASK_INFOGetPayload<T>>>>

    /**
     * Create a TASK_INFO.
     * @param {TASK_INFOCreateArgs} args - Arguments to create a TASK_INFO.
     * @example
     * // Create one TASK_INFO
     * const TASK_INFO = await prisma.tASK_INFO.create({
     *   data: {
     *     // ... data to create a TASK_INFO
     *   }
     * })
     * 
    **/
    create<T extends TASK_INFOCreateArgs>(
      args: SelectSubset<T, TASK_INFOCreateArgs>
    ): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>>

    /**
     * Create many TASK_INFOS.
     *     @param {TASK_INFOCreateManyArgs} args - Arguments to create many TASK_INFOS.
     *     @example
     *     // Create many TASK_INFOS
     *     const tASK_INFO = await prisma.tASK_INFO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TASK_INFOCreateManyArgs>(
      args?: SelectSubset<T, TASK_INFOCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TASK_INFO.
     * @param {TASK_INFODeleteArgs} args - Arguments to delete one TASK_INFO.
     * @example
     * // Delete one TASK_INFO
     * const TASK_INFO = await prisma.tASK_INFO.delete({
     *   where: {
     *     // ... filter to delete one TASK_INFO
     *   }
     * })
     * 
    **/
    delete<T extends TASK_INFODeleteArgs>(
      args: SelectSubset<T, TASK_INFODeleteArgs>
    ): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>>

    /**
     * Update one TASK_INFO.
     * @param {TASK_INFOUpdateArgs} args - Arguments to update one TASK_INFO.
     * @example
     * // Update one TASK_INFO
     * const tASK_INFO = await prisma.tASK_INFO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TASK_INFOUpdateArgs>(
      args: SelectSubset<T, TASK_INFOUpdateArgs>
    ): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>>

    /**
     * Delete zero or more TASK_INFOS.
     * @param {TASK_INFODeleteManyArgs} args - Arguments to filter TASK_INFOS to delete.
     * @example
     * // Delete a few TASK_INFOS
     * const { count } = await prisma.tASK_INFO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TASK_INFODeleteManyArgs>(
      args?: SelectSubset<T, TASK_INFODeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TASK_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TASK_INFOS
     * const tASK_INFO = await prisma.tASK_INFO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TASK_INFOUpdateManyArgs>(
      args: SelectSubset<T, TASK_INFOUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TASK_INFO.
     * @param {TASK_INFOUpsertArgs} args - Arguments to update or create a TASK_INFO.
     * @example
     * // Update or create a TASK_INFO
     * const tASK_INFO = await prisma.tASK_INFO.upsert({
     *   create: {
     *     // ... data to create a TASK_INFO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TASK_INFO we want to update
     *   }
     * })
    **/
    upsert<T extends TASK_INFOUpsertArgs>(
      args: SelectSubset<T, TASK_INFOUpsertArgs>
    ): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>>

    /**
     * Find one TASK_INFO that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TASK_INFOFindUniqueOrThrowArgs} args - Arguments to find a TASK_INFO
     * @example
     * // Get one TASK_INFO
     * const tASK_INFO = await prisma.tASK_INFO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TASK_INFOFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TASK_INFOFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>>

    /**
     * Find the first TASK_INFO that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOFindFirstOrThrowArgs} args - Arguments to find a TASK_INFO
     * @example
     * // Get one TASK_INFO
     * const tASK_INFO = await prisma.tASK_INFO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TASK_INFOFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TASK_INFOFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO>, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T>>>

    /**
     * Count the number of TASK_INFOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOCountArgs} args - Arguments to filter TASK_INFOS to count.
     * @example
     * // Count the number of TASK_INFOS
     * const count = await prisma.tASK_INFO.count({
     *   where: {
     *     // ... the filter for the TASK_INFOS we want to count
     *   }
     * })
    **/
    count<T extends TASK_INFOCountArgs>(
      args?: Subset<T, TASK_INFOCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TASK_INFOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TASK_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TASK_INFOAggregateArgs>(args: Subset<T, TASK_INFOAggregateArgs>): PrismaPromise<GetTASK_INFOAggregateType<T>>

    /**
     * Group by TASK_INFO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_INFOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TASK_INFOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TASK_INFOGroupByArgs['orderBy'] }
        : { orderBy?: TASK_INFOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TASK_INFOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTASK_INFOGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TASK_INFO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TASK_INFOClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PROJECT_INFO<T extends PROJECT_INFOArgs = {}>(args?: Subset<T, PROJECT_INFOArgs>): CheckSelect<T, Prisma__PROJECT_INFOClient<PROJECT_INFO | null >, Prisma__PROJECT_INFOClient<PROJECT_INFOGetPayload<T> | null >>;

    PROJECT_MEMBER<T extends PROJECT_MEMBERArgs = {}>(args?: Subset<T, PROJECT_MEMBERArgs>): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER | null >, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T> | null >>;

    TASK_RESPONDSIPLE<T extends TASK_RESPONDSIPLEFindManyArgs = {}>(args?: Subset<T, TASK_RESPONDSIPLEFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TASK_RESPONDSIPLE>>, PrismaPromise<Array<TASK_RESPONDSIPLEGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TASK_INFO base type for findUnique actions
   */
  export type TASK_INFOFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * Filter, which TASK_INFO to fetch.
     * 
    **/
    where: TASK_INFOWhereUniqueInput
  }

  /**
   * TASK_INFO: findUnique
   */
  export interface TASK_INFOFindUniqueArgs extends TASK_INFOFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TASK_INFO base type for findFirst actions
   */
  export type TASK_INFOFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * Filter, which TASK_INFO to fetch.
     * 
    **/
    where?: TASK_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TASK_INFOS.
     * 
    **/
    cursor?: TASK_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_INFOS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TASK_INFOS.
     * 
    **/
    distinct?: Enumerable<TASK_INFOScalarFieldEnum>
  }

  /**
   * TASK_INFO: findFirst
   */
  export interface TASK_INFOFindFirstArgs extends TASK_INFOFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TASK_INFO findMany
   */
  export type TASK_INFOFindManyArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * Filter, which TASK_INFOS to fetch.
     * 
    **/
    where?: TASK_INFOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_INFOS to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_INFOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TASK_INFOS.
     * 
    **/
    cursor?: TASK_INFOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_INFOS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_INFOS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TASK_INFOScalarFieldEnum>
  }


  /**
   * TASK_INFO create
   */
  export type TASK_INFOCreateArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * The data needed to create a TASK_INFO.
     * 
    **/
    data: XOR<TASK_INFOCreateInput, TASK_INFOUncheckedCreateInput>
  }


  /**
   * TASK_INFO createMany
   */
  export type TASK_INFOCreateManyArgs = {
    /**
     * The data used to create many TASK_INFOS.
     * 
    **/
    data: Enumerable<TASK_INFOCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TASK_INFO update
   */
  export type TASK_INFOUpdateArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * The data needed to update a TASK_INFO.
     * 
    **/
    data: XOR<TASK_INFOUpdateInput, TASK_INFOUncheckedUpdateInput>
    /**
     * Choose, which TASK_INFO to update.
     * 
    **/
    where: TASK_INFOWhereUniqueInput
  }


  /**
   * TASK_INFO updateMany
   */
  export type TASK_INFOUpdateManyArgs = {
    /**
     * The data used to update TASK_INFOS.
     * 
    **/
    data: XOR<TASK_INFOUpdateManyMutationInput, TASK_INFOUncheckedUpdateManyInput>
    /**
     * Filter which TASK_INFOS to update
     * 
    **/
    where?: TASK_INFOWhereInput
  }


  /**
   * TASK_INFO upsert
   */
  export type TASK_INFOUpsertArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * The filter to search for the TASK_INFO to update in case it exists.
     * 
    **/
    where: TASK_INFOWhereUniqueInput
    /**
     * In case the TASK_INFO found by the `where` argument doesn't exist, create a new TASK_INFO with this data.
     * 
    **/
    create: XOR<TASK_INFOCreateInput, TASK_INFOUncheckedCreateInput>
    /**
     * In case the TASK_INFO was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TASK_INFOUpdateInput, TASK_INFOUncheckedUpdateInput>
  }


  /**
   * TASK_INFO delete
   */
  export type TASK_INFODeleteArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
    /**
     * Filter which TASK_INFO to delete.
     * 
    **/
    where: TASK_INFOWhereUniqueInput
  }


  /**
   * TASK_INFO deleteMany
   */
  export type TASK_INFODeleteManyArgs = {
    /**
     * Filter which TASK_INFOS to delete
     * 
    **/
    where?: TASK_INFOWhereInput
  }


  /**
   * TASK_INFO: findUniqueOrThrow
   */
  export type TASK_INFOFindUniqueOrThrowArgs = TASK_INFOFindUniqueArgsBase
      

  /**
   * TASK_INFO: findFirstOrThrow
   */
  export type TASK_INFOFindFirstOrThrowArgs = TASK_INFOFindFirstArgsBase
      

  /**
   * TASK_INFO without action
   */
  export type TASK_INFOArgs = {
    /**
     * Select specific fields to fetch from the TASK_INFO
     * 
    **/
    select?: TASK_INFOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_INFOInclude | null
  }



  /**
   * Model TASK_RESPONDSIPLE
   */


  export type AggregateTASK_RESPONDSIPLE = {
    _count: TASK_RESPONDSIPLECountAggregateOutputType | null
    _avg: TASK_RESPONDSIPLEAvgAggregateOutputType | null
    _sum: TASK_RESPONDSIPLESumAggregateOutputType | null
    _min: TASK_RESPONDSIPLEMinAggregateOutputType | null
    _max: TASK_RESPONDSIPLEMaxAggregateOutputType | null
  }

  export type TASK_RESPONDSIPLEAvgAggregateOutputType = {
    PJ_ID: number | null
    TASK_ID: number | null
    MEM_ID: number | null
  }

  export type TASK_RESPONDSIPLESumAggregateOutputType = {
    PJ_ID: bigint | null
    TASK_ID: bigint | null
    MEM_ID: bigint | null
  }

  export type TASK_RESPONDSIPLEMinAggregateOutputType = {
    PJ_ID: bigint | null
    TASK_ID: bigint | null
    MEM_ID: bigint | null
  }

  export type TASK_RESPONDSIPLEMaxAggregateOutputType = {
    PJ_ID: bigint | null
    TASK_ID: bigint | null
    MEM_ID: bigint | null
  }

  export type TASK_RESPONDSIPLECountAggregateOutputType = {
    PJ_ID: number
    TASK_ID: number
    MEM_ID: number
    _all: number
  }


  export type TASK_RESPONDSIPLEAvgAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    MEM_ID?: true
  }

  export type TASK_RESPONDSIPLESumAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    MEM_ID?: true
  }

  export type TASK_RESPONDSIPLEMinAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    MEM_ID?: true
  }

  export type TASK_RESPONDSIPLEMaxAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    MEM_ID?: true
  }

  export type TASK_RESPONDSIPLECountAggregateInputType = {
    PJ_ID?: true
    TASK_ID?: true
    MEM_ID?: true
    _all?: true
  }

  export type TASK_RESPONDSIPLEAggregateArgs = {
    /**
     * Filter which TASK_RESPONDSIPLE to aggregate.
     * 
    **/
    where?: TASK_RESPONDSIPLEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_RESPONDSIPLES to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_RESPONDSIPLEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TASK_RESPONDSIPLEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_RESPONDSIPLES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_RESPONDSIPLES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TASK_RESPONDSIPLES
    **/
    _count?: true | TASK_RESPONDSIPLECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TASK_RESPONDSIPLEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TASK_RESPONDSIPLESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TASK_RESPONDSIPLEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TASK_RESPONDSIPLEMaxAggregateInputType
  }

  export type GetTASK_RESPONDSIPLEAggregateType<T extends TASK_RESPONDSIPLEAggregateArgs> = {
        [P in keyof T & keyof AggregateTASK_RESPONDSIPLE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTASK_RESPONDSIPLE[P]>
      : GetScalarType<T[P], AggregateTASK_RESPONDSIPLE[P]>
  }




  export type TASK_RESPONDSIPLEGroupByArgs = {
    where?: TASK_RESPONDSIPLEWhereInput
    orderBy?: Enumerable<TASK_RESPONDSIPLEOrderByWithAggregationInput>
    by: Array<TASK_RESPONDSIPLEScalarFieldEnum>
    having?: TASK_RESPONDSIPLEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TASK_RESPONDSIPLECountAggregateInputType | true
    _avg?: TASK_RESPONDSIPLEAvgAggregateInputType
    _sum?: TASK_RESPONDSIPLESumAggregateInputType
    _min?: TASK_RESPONDSIPLEMinAggregateInputType
    _max?: TASK_RESPONDSIPLEMaxAggregateInputType
  }


  export type TASK_RESPONDSIPLEGroupByOutputType = {
    PJ_ID: bigint
    TASK_ID: bigint
    MEM_ID: bigint
    _count: TASK_RESPONDSIPLECountAggregateOutputType | null
    _avg: TASK_RESPONDSIPLEAvgAggregateOutputType | null
    _sum: TASK_RESPONDSIPLESumAggregateOutputType | null
    _min: TASK_RESPONDSIPLEMinAggregateOutputType | null
    _max: TASK_RESPONDSIPLEMaxAggregateOutputType | null
  }

  type GetTASK_RESPONDSIPLEGroupByPayload<T extends TASK_RESPONDSIPLEGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TASK_RESPONDSIPLEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TASK_RESPONDSIPLEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TASK_RESPONDSIPLEGroupByOutputType[P]>
            : GetScalarType<T[P], TASK_RESPONDSIPLEGroupByOutputType[P]>
        }
      >
    >


  export type TASK_RESPONDSIPLESelect = {
    PJ_ID?: boolean
    TASK_ID?: boolean
    MEM_ID?: boolean
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERArgs
    TASK_INFO?: boolean | TASK_INFOArgs
  }

  export type TASK_RESPONDSIPLEInclude = {
    PROJECT_MEMBER?: boolean | PROJECT_MEMBERArgs
    TASK_INFO?: boolean | TASK_INFOArgs
  }

  export type TASK_RESPONDSIPLEGetPayload<
    S extends boolean | null | undefined | TASK_RESPONDSIPLEArgs,
    U = keyof S
      > = S extends true
        ? TASK_RESPONDSIPLE
    : S extends undefined
    ? never
    : S extends TASK_RESPONDSIPLEArgs | TASK_RESPONDSIPLEFindManyArgs
    ?'include' extends U
    ? TASK_RESPONDSIPLE  & {
    [P in TrueKeys<S['include']>]:
        P extends 'PROJECT_MEMBER' ? PROJECT_MEMBERGetPayload<S['include'][P]> :
        P extends 'TASK_INFO' ? TASK_INFOGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'PROJECT_MEMBER' ? PROJECT_MEMBERGetPayload<S['select'][P]> :
        P extends 'TASK_INFO' ? TASK_INFOGetPayload<S['select'][P]> :  P extends keyof TASK_RESPONDSIPLE ? TASK_RESPONDSIPLE[P] : never
  } 
    : TASK_RESPONDSIPLE
  : TASK_RESPONDSIPLE


  type TASK_RESPONDSIPLECountArgs = Merge<
    Omit<TASK_RESPONDSIPLEFindManyArgs, 'select' | 'include'> & {
      select?: TASK_RESPONDSIPLECountAggregateInputType | true
    }
  >

  export interface TASK_RESPONDSIPLEDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TASK_RESPONDSIPLE that matches the filter.
     * @param {TASK_RESPONDSIPLEFindUniqueArgs} args - Arguments to find a TASK_RESPONDSIPLE
     * @example
     * // Get one TASK_RESPONDSIPLE
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TASK_RESPONDSIPLEFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TASK_RESPONDSIPLEFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TASK_RESPONDSIPLE'> extends True ? CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>> : CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE | null >, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T> | null >>

    /**
     * Find the first TASK_RESPONDSIPLE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLEFindFirstArgs} args - Arguments to find a TASK_RESPONDSIPLE
     * @example
     * // Get one TASK_RESPONDSIPLE
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TASK_RESPONDSIPLEFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TASK_RESPONDSIPLEFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TASK_RESPONDSIPLE'> extends True ? CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>> : CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE | null >, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T> | null >>

    /**
     * Find zero or more TASK_RESPONDSIPLES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TASK_RESPONDSIPLES
     * const tASK_RESPONDSIPLES = await prisma.tASK_RESPONDSIPLE.findMany()
     * 
     * // Get first 10 TASK_RESPONDSIPLES
     * const tASK_RESPONDSIPLES = await prisma.tASK_RESPONDSIPLE.findMany({ take: 10 })
     * 
     * // Only select the `PJ_ID`
     * const tASK_RESPONDSIPLEWithPJ_IDOnly = await prisma.tASK_RESPONDSIPLE.findMany({ select: { PJ_ID: true } })
     * 
    **/
    findMany<T extends TASK_RESPONDSIPLEFindManyArgs>(
      args?: SelectSubset<T, TASK_RESPONDSIPLEFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TASK_RESPONDSIPLE>>, PrismaPromise<Array<TASK_RESPONDSIPLEGetPayload<T>>>>

    /**
     * Create a TASK_RESPONDSIPLE.
     * @param {TASK_RESPONDSIPLECreateArgs} args - Arguments to create a TASK_RESPONDSIPLE.
     * @example
     * // Create one TASK_RESPONDSIPLE
     * const TASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.create({
     *   data: {
     *     // ... data to create a TASK_RESPONDSIPLE
     *   }
     * })
     * 
    **/
    create<T extends TASK_RESPONDSIPLECreateArgs>(
      args: SelectSubset<T, TASK_RESPONDSIPLECreateArgs>
    ): CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>>

    /**
     * Create many TASK_RESPONDSIPLES.
     *     @param {TASK_RESPONDSIPLECreateManyArgs} args - Arguments to create many TASK_RESPONDSIPLES.
     *     @example
     *     // Create many TASK_RESPONDSIPLES
     *     const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TASK_RESPONDSIPLECreateManyArgs>(
      args?: SelectSubset<T, TASK_RESPONDSIPLECreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TASK_RESPONDSIPLE.
     * @param {TASK_RESPONDSIPLEDeleteArgs} args - Arguments to delete one TASK_RESPONDSIPLE.
     * @example
     * // Delete one TASK_RESPONDSIPLE
     * const TASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.delete({
     *   where: {
     *     // ... filter to delete one TASK_RESPONDSIPLE
     *   }
     * })
     * 
    **/
    delete<T extends TASK_RESPONDSIPLEDeleteArgs>(
      args: SelectSubset<T, TASK_RESPONDSIPLEDeleteArgs>
    ): CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>>

    /**
     * Update one TASK_RESPONDSIPLE.
     * @param {TASK_RESPONDSIPLEUpdateArgs} args - Arguments to update one TASK_RESPONDSIPLE.
     * @example
     * // Update one TASK_RESPONDSIPLE
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TASK_RESPONDSIPLEUpdateArgs>(
      args: SelectSubset<T, TASK_RESPONDSIPLEUpdateArgs>
    ): CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>>

    /**
     * Delete zero or more TASK_RESPONDSIPLES.
     * @param {TASK_RESPONDSIPLEDeleteManyArgs} args - Arguments to filter TASK_RESPONDSIPLES to delete.
     * @example
     * // Delete a few TASK_RESPONDSIPLES
     * const { count } = await prisma.tASK_RESPONDSIPLE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TASK_RESPONDSIPLEDeleteManyArgs>(
      args?: SelectSubset<T, TASK_RESPONDSIPLEDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TASK_RESPONDSIPLES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TASK_RESPONDSIPLES
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TASK_RESPONDSIPLEUpdateManyArgs>(
      args: SelectSubset<T, TASK_RESPONDSIPLEUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TASK_RESPONDSIPLE.
     * @param {TASK_RESPONDSIPLEUpsertArgs} args - Arguments to update or create a TASK_RESPONDSIPLE.
     * @example
     * // Update or create a TASK_RESPONDSIPLE
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.upsert({
     *   create: {
     *     // ... data to create a TASK_RESPONDSIPLE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TASK_RESPONDSIPLE we want to update
     *   }
     * })
    **/
    upsert<T extends TASK_RESPONDSIPLEUpsertArgs>(
      args: SelectSubset<T, TASK_RESPONDSIPLEUpsertArgs>
    ): CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>>

    /**
     * Find one TASK_RESPONDSIPLE that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {TASK_RESPONDSIPLEFindUniqueOrThrowArgs} args - Arguments to find a TASK_RESPONDSIPLE
     * @example
     * // Get one TASK_RESPONDSIPLE
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TASK_RESPONDSIPLEFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TASK_RESPONDSIPLEFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>>

    /**
     * Find the first TASK_RESPONDSIPLE that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLEFindFirstOrThrowArgs} args - Arguments to find a TASK_RESPONDSIPLE
     * @example
     * // Get one TASK_RESPONDSIPLE
     * const tASK_RESPONDSIPLE = await prisma.tASK_RESPONDSIPLE.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TASK_RESPONDSIPLEFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TASK_RESPONDSIPLEFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLE>, Prisma__TASK_RESPONDSIPLEClient<TASK_RESPONDSIPLEGetPayload<T>>>

    /**
     * Count the number of TASK_RESPONDSIPLES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLECountArgs} args - Arguments to filter TASK_RESPONDSIPLES to count.
     * @example
     * // Count the number of TASK_RESPONDSIPLES
     * const count = await prisma.tASK_RESPONDSIPLE.count({
     *   where: {
     *     // ... the filter for the TASK_RESPONDSIPLES we want to count
     *   }
     * })
    **/
    count<T extends TASK_RESPONDSIPLECountArgs>(
      args?: Subset<T, TASK_RESPONDSIPLECountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TASK_RESPONDSIPLECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TASK_RESPONDSIPLE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TASK_RESPONDSIPLEAggregateArgs>(args: Subset<T, TASK_RESPONDSIPLEAggregateArgs>): PrismaPromise<GetTASK_RESPONDSIPLEAggregateType<T>>

    /**
     * Group by TASK_RESPONDSIPLE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TASK_RESPONDSIPLEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TASK_RESPONDSIPLEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TASK_RESPONDSIPLEGroupByArgs['orderBy'] }
        : { orderBy?: TASK_RESPONDSIPLEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TASK_RESPONDSIPLEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTASK_RESPONDSIPLEGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TASK_RESPONDSIPLE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TASK_RESPONDSIPLEClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    PROJECT_MEMBER<T extends PROJECT_MEMBERArgs = {}>(args?: Subset<T, PROJECT_MEMBERArgs>): CheckSelect<T, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBER | null >, Prisma__PROJECT_MEMBERClient<PROJECT_MEMBERGetPayload<T> | null >>;

    TASK_INFO<T extends TASK_INFOArgs = {}>(args?: Subset<T, TASK_INFOArgs>): CheckSelect<T, Prisma__TASK_INFOClient<TASK_INFO | null >, Prisma__TASK_INFOClient<TASK_INFOGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TASK_RESPONDSIPLE base type for findUnique actions
   */
  export type TASK_RESPONDSIPLEFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * Filter, which TASK_RESPONDSIPLE to fetch.
     * 
    **/
    where: TASK_RESPONDSIPLEWhereUniqueInput
  }

  /**
   * TASK_RESPONDSIPLE: findUnique
   */
  export interface TASK_RESPONDSIPLEFindUniqueArgs extends TASK_RESPONDSIPLEFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TASK_RESPONDSIPLE base type for findFirst actions
   */
  export type TASK_RESPONDSIPLEFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * Filter, which TASK_RESPONDSIPLE to fetch.
     * 
    **/
    where?: TASK_RESPONDSIPLEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_RESPONDSIPLES to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_RESPONDSIPLEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TASK_RESPONDSIPLES.
     * 
    **/
    cursor?: TASK_RESPONDSIPLEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_RESPONDSIPLES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_RESPONDSIPLES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TASK_RESPONDSIPLES.
     * 
    **/
    distinct?: Enumerable<TASK_RESPONDSIPLEScalarFieldEnum>
  }

  /**
   * TASK_RESPONDSIPLE: findFirst
   */
  export interface TASK_RESPONDSIPLEFindFirstArgs extends TASK_RESPONDSIPLEFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TASK_RESPONDSIPLE findMany
   */
  export type TASK_RESPONDSIPLEFindManyArgs = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * Filter, which TASK_RESPONDSIPLES to fetch.
     * 
    **/
    where?: TASK_RESPONDSIPLEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TASK_RESPONDSIPLES to fetch.
     * 
    **/
    orderBy?: Enumerable<TASK_RESPONDSIPLEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TASK_RESPONDSIPLES.
     * 
    **/
    cursor?: TASK_RESPONDSIPLEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TASK_RESPONDSIPLES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TASK_RESPONDSIPLES.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TASK_RESPONDSIPLEScalarFieldEnum>
  }


  /**
   * TASK_RESPONDSIPLE create
   */
  export type TASK_RESPONDSIPLECreateArgs = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * The data needed to create a TASK_RESPONDSIPLE.
     * 
    **/
    data: XOR<TASK_RESPONDSIPLECreateInput, TASK_RESPONDSIPLEUncheckedCreateInput>
  }


  /**
   * TASK_RESPONDSIPLE createMany
   */
  export type TASK_RESPONDSIPLECreateManyArgs = {
    /**
     * The data used to create many TASK_RESPONDSIPLES.
     * 
    **/
    data: Enumerable<TASK_RESPONDSIPLECreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TASK_RESPONDSIPLE update
   */
  export type TASK_RESPONDSIPLEUpdateArgs = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * The data needed to update a TASK_RESPONDSIPLE.
     * 
    **/
    data: XOR<TASK_RESPONDSIPLEUpdateInput, TASK_RESPONDSIPLEUncheckedUpdateInput>
    /**
     * Choose, which TASK_RESPONDSIPLE to update.
     * 
    **/
    where: TASK_RESPONDSIPLEWhereUniqueInput
  }


  /**
   * TASK_RESPONDSIPLE updateMany
   */
  export type TASK_RESPONDSIPLEUpdateManyArgs = {
    /**
     * The data used to update TASK_RESPONDSIPLES.
     * 
    **/
    data: XOR<TASK_RESPONDSIPLEUpdateManyMutationInput, TASK_RESPONDSIPLEUncheckedUpdateManyInput>
    /**
     * Filter which TASK_RESPONDSIPLES to update
     * 
    **/
    where?: TASK_RESPONDSIPLEWhereInput
  }


  /**
   * TASK_RESPONDSIPLE upsert
   */
  export type TASK_RESPONDSIPLEUpsertArgs = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * The filter to search for the TASK_RESPONDSIPLE to update in case it exists.
     * 
    **/
    where: TASK_RESPONDSIPLEWhereUniqueInput
    /**
     * In case the TASK_RESPONDSIPLE found by the `where` argument doesn't exist, create a new TASK_RESPONDSIPLE with this data.
     * 
    **/
    create: XOR<TASK_RESPONDSIPLECreateInput, TASK_RESPONDSIPLEUncheckedCreateInput>
    /**
     * In case the TASK_RESPONDSIPLE was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TASK_RESPONDSIPLEUpdateInput, TASK_RESPONDSIPLEUncheckedUpdateInput>
  }


  /**
   * TASK_RESPONDSIPLE delete
   */
  export type TASK_RESPONDSIPLEDeleteArgs = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
    /**
     * Filter which TASK_RESPONDSIPLE to delete.
     * 
    **/
    where: TASK_RESPONDSIPLEWhereUniqueInput
  }


  /**
   * TASK_RESPONDSIPLE deleteMany
   */
  export type TASK_RESPONDSIPLEDeleteManyArgs = {
    /**
     * Filter which TASK_RESPONDSIPLES to delete
     * 
    **/
    where?: TASK_RESPONDSIPLEWhereInput
  }


  /**
   * TASK_RESPONDSIPLE: findUniqueOrThrow
   */
  export type TASK_RESPONDSIPLEFindUniqueOrThrowArgs = TASK_RESPONDSIPLEFindUniqueArgsBase
      

  /**
   * TASK_RESPONDSIPLE: findFirstOrThrow
   */
  export type TASK_RESPONDSIPLEFindFirstOrThrowArgs = TASK_RESPONDSIPLEFindFirstArgsBase
      

  /**
   * TASK_RESPONDSIPLE without action
   */
  export type TASK_RESPONDSIPLEArgs = {
    /**
     * Select specific fields to fetch from the TASK_RESPONDSIPLE
     * 
    **/
    select?: TASK_RESPONDSIPLESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TASK_RESPONDSIPLEInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const USER_ACCOUNTScalarFieldEnum: {
    US_ID: 'US_ID',
    US_ACCOUNT: 'US_ACCOUNT',
    US_PASSWORD: 'US_PASSWORD',
    TOKEN: 'TOKEN'
  };

  export type USER_ACCOUNTScalarFieldEnum = (typeof USER_ACCOUNTScalarFieldEnum)[keyof typeof USER_ACCOUNTScalarFieldEnum]


  export const USER_INFOScalarFieldEnum: {
    US_ID: 'US_ID',
    US_NAME: 'US_NAME',
    US_MAIL: 'US_MAIL',
    US_PHONE: 'US_PHONE',
    US_BIRTH: 'US_BIRTH',
    US_GENDER: 'US_GENDER',
    US_ADDRESS: 'US_ADDRESS'
  };

  export type USER_INFOScalarFieldEnum = (typeof USER_INFOScalarFieldEnum)[keyof typeof USER_INFOScalarFieldEnum]


  export const PROJECT_ACCESSIBILITYScalarFieldEnum: {
    MEM_POS: 'MEM_POS',
    DEL_PJ: 'DEL_PJ',
    EDIT_MEM_POS: 'EDIT_MEM_POS',
    EDIT_MEM: 'EDIT_MEM',
    EDIT_STATUS: 'EDIT_STATUS',
    CREATE_ANNOUNC_MNT: 'CREATE_ANNOUNC_MNT'
  };

  export type PROJECT_ACCESSIBILITYScalarFieldEnum = (typeof PROJECT_ACCESSIBILITYScalarFieldEnum)[keyof typeof PROJECT_ACCESSIBILITYScalarFieldEnum]


  export const PROJECT_INFOScalarFieldEnum: {
    PJ_ID: 'PJ_ID',
    PJ_NAME: 'PJ_NAME',
    PJ_CREATEDAY: 'PJ_CREATEDAY',
    PJ_DEADLINE: 'PJ_DEADLINE',
    PJ_STATUS: 'PJ_STATUS',
    PJ_ADMIN: 'PJ_ADMIN',
    PJ_OWNER: 'PJ_OWNER'
  };

  export type PROJECT_INFOScalarFieldEnum = (typeof PROJECT_INFOScalarFieldEnum)[keyof typeof PROJECT_INFOScalarFieldEnum]


  export const PROJECT_MEMBERScalarFieldEnum: {
    PJ_ID: 'PJ_ID',
    MEM_ID: 'MEM_ID',
    MEM_POS: 'MEM_POS'
  };

  export type PROJECT_MEMBERScalarFieldEnum = (typeof PROJECT_MEMBERScalarFieldEnum)[keyof typeof PROJECT_MEMBERScalarFieldEnum]


  export const TASK_ACCESSIBILITYScalarFieldEnum: {
    MEM_POS: 'MEM_POS',
    EDIT_MEM: 'EDIT_MEM',
    ADD_TASK: 'ADD_TASK',
    DEL_TASK: 'DEL_TASK',
    EDIT_NAME: 'EDIT_NAME',
    EDIT_DEADLINE: 'EDIT_DEADLINE',
    EDIT_STATUS: 'EDIT_STATUS',
    EDIT_DESCRIPTION: 'EDIT_DESCRIPTION'
  };

  export type TASK_ACCESSIBILITYScalarFieldEnum = (typeof TASK_ACCESSIBILITYScalarFieldEnum)[keyof typeof TASK_ACCESSIBILITYScalarFieldEnum]


  export const TASK_INFOScalarFieldEnum: {
    PJ_ID: 'PJ_ID',
    TASK_ID: 'TASK_ID',
    TASK_STATUS: 'TASK_STATUS',
    TASK_NAME: 'TASK_NAME',
    TASK_DESCRIPTON: 'TASK_DESCRIPTON',
    TASK_CREATEDAY: 'TASK_CREATEDAY',
    TASK_DEADLINE: 'TASK_DEADLINE',
    TASK_CREATOR: 'TASK_CREATOR'
  };

  export type TASK_INFOScalarFieldEnum = (typeof TASK_INFOScalarFieldEnum)[keyof typeof TASK_INFOScalarFieldEnum]


  export const TASK_RESPONDSIPLEScalarFieldEnum: {
    PJ_ID: 'PJ_ID',
    TASK_ID: 'TASK_ID',
    MEM_ID: 'MEM_ID'
  };

  export type TASK_RESPONDSIPLEScalarFieldEnum = (typeof TASK_RESPONDSIPLEScalarFieldEnum)[keyof typeof TASK_RESPONDSIPLEScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type USER_ACCOUNTWhereInput = {
    AND?: Enumerable<USER_ACCOUNTWhereInput>
    OR?: Enumerable<USER_ACCOUNTWhereInput>
    NOT?: Enumerable<USER_ACCOUNTWhereInput>
    US_ID?: BigIntFilter | bigint | number
    US_ACCOUNT?: StringFilter | string
    US_PASSWORD?: StringFilter | string
    TOKEN?: StringNullableFilter | string | null
    USER_INFO?: XOR<USER_INFORelationFilter, USER_INFOWhereInput> | null
  }

  export type USER_ACCOUNTOrderByWithRelationInput = {
    US_ID?: SortOrder
    US_ACCOUNT?: SortOrder
    US_PASSWORD?: SortOrder
    TOKEN?: SortOrder
    USER_INFO?: USER_INFOOrderByWithRelationInput
  }

  export type USER_ACCOUNTWhereUniqueInput = {
    US_ID?: bigint | number
  }

  export type USER_ACCOUNTOrderByWithAggregationInput = {
    US_ID?: SortOrder
    US_ACCOUNT?: SortOrder
    US_PASSWORD?: SortOrder
    TOKEN?: SortOrder
    _count?: USER_ACCOUNTCountOrderByAggregateInput
    _avg?: USER_ACCOUNTAvgOrderByAggregateInput
    _max?: USER_ACCOUNTMaxOrderByAggregateInput
    _min?: USER_ACCOUNTMinOrderByAggregateInput
    _sum?: USER_ACCOUNTSumOrderByAggregateInput
  }

  export type USER_ACCOUNTScalarWhereWithAggregatesInput = {
    AND?: Enumerable<USER_ACCOUNTScalarWhereWithAggregatesInput>
    OR?: Enumerable<USER_ACCOUNTScalarWhereWithAggregatesInput>
    NOT?: Enumerable<USER_ACCOUNTScalarWhereWithAggregatesInput>
    US_ID?: BigIntWithAggregatesFilter | bigint | number
    US_ACCOUNT?: StringWithAggregatesFilter | string
    US_PASSWORD?: StringWithAggregatesFilter | string
    TOKEN?: StringNullableWithAggregatesFilter | string | null
  }

  export type USER_INFOWhereInput = {
    AND?: Enumerable<USER_INFOWhereInput>
    OR?: Enumerable<USER_INFOWhereInput>
    NOT?: Enumerable<USER_INFOWhereInput>
    US_ID?: BigIntFilter | bigint | number
    US_NAME?: StringNullableFilter | string | null
    US_MAIL?: StringNullableFilter | string | null
    US_PHONE?: StringNullableFilter | string | null
    US_BIRTH?: DateTimeNullableFilter | Date | string | null
    US_GENDER?: StringNullableFilter | string | null
    US_ADDRESS?: StringNullableFilter | string | null
    USER_ACCOUNT?: XOR<USER_ACCOUNTRelationFilter, USER_ACCOUNTWhereInput>
    PROJECT_MEMBER?: PROJECT_MEMBERListRelationFilter
  }

  export type USER_INFOOrderByWithRelationInput = {
    US_ID?: SortOrder
    US_NAME?: SortOrder
    US_MAIL?: SortOrder
    US_PHONE?: SortOrder
    US_BIRTH?: SortOrder
    US_GENDER?: SortOrder
    US_ADDRESS?: SortOrder
    USER_ACCOUNT?: USER_ACCOUNTOrderByWithRelationInput
    PROJECT_MEMBER?: PROJECT_MEMBEROrderByRelationAggregateInput
  }

  export type USER_INFOWhereUniqueInput = {
    US_ID?: bigint | number
  }

  export type USER_INFOOrderByWithAggregationInput = {
    US_ID?: SortOrder
    US_NAME?: SortOrder
    US_MAIL?: SortOrder
    US_PHONE?: SortOrder
    US_BIRTH?: SortOrder
    US_GENDER?: SortOrder
    US_ADDRESS?: SortOrder
    _count?: USER_INFOCountOrderByAggregateInput
    _avg?: USER_INFOAvgOrderByAggregateInput
    _max?: USER_INFOMaxOrderByAggregateInput
    _min?: USER_INFOMinOrderByAggregateInput
    _sum?: USER_INFOSumOrderByAggregateInput
  }

  export type USER_INFOScalarWhereWithAggregatesInput = {
    AND?: Enumerable<USER_INFOScalarWhereWithAggregatesInput>
    OR?: Enumerable<USER_INFOScalarWhereWithAggregatesInput>
    NOT?: Enumerable<USER_INFOScalarWhereWithAggregatesInput>
    US_ID?: BigIntWithAggregatesFilter | bigint | number
    US_NAME?: StringNullableWithAggregatesFilter | string | null
    US_MAIL?: StringNullableWithAggregatesFilter | string | null
    US_PHONE?: StringNullableWithAggregatesFilter | string | null
    US_BIRTH?: DateTimeNullableWithAggregatesFilter | Date | string | null
    US_GENDER?: StringNullableWithAggregatesFilter | string | null
    US_ADDRESS?: StringNullableWithAggregatesFilter | string | null
  }

  export type PROJECT_ACCESSIBILITYWhereInput = {
    AND?: Enumerable<PROJECT_ACCESSIBILITYWhereInput>
    OR?: Enumerable<PROJECT_ACCESSIBILITYWhereInput>
    NOT?: Enumerable<PROJECT_ACCESSIBILITYWhereInput>
    MEM_POS?: BigIntFilter | bigint | number
    DEL_PJ?: StringNullableFilter | string | null
    EDIT_MEM_POS?: StringNullableFilter | string | null
    EDIT_MEM?: StringNullableFilter | string | null
    EDIT_STATUS?: StringNullableFilter | string | null
    CREATE_ANNOUNC_MNT?: StringNullableFilter | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERListRelationFilter
  }

  export type PROJECT_ACCESSIBILITYOrderByWithRelationInput = {
    MEM_POS?: SortOrder
    DEL_PJ?: SortOrder
    EDIT_MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    EDIT_STATUS?: SortOrder
    CREATE_ANNOUNC_MNT?: SortOrder
    PROJECT_MEMBER?: PROJECT_MEMBEROrderByRelationAggregateInput
  }

  export type PROJECT_ACCESSIBILITYWhereUniqueInput = {
    MEM_POS?: bigint | number
  }

  export type PROJECT_ACCESSIBILITYOrderByWithAggregationInput = {
    MEM_POS?: SortOrder
    DEL_PJ?: SortOrder
    EDIT_MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    EDIT_STATUS?: SortOrder
    CREATE_ANNOUNC_MNT?: SortOrder
    _count?: PROJECT_ACCESSIBILITYCountOrderByAggregateInput
    _avg?: PROJECT_ACCESSIBILITYAvgOrderByAggregateInput
    _max?: PROJECT_ACCESSIBILITYMaxOrderByAggregateInput
    _min?: PROJECT_ACCESSIBILITYMinOrderByAggregateInput
    _sum?: PROJECT_ACCESSIBILITYSumOrderByAggregateInput
  }

  export type PROJECT_ACCESSIBILITYScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PROJECT_ACCESSIBILITYScalarWhereWithAggregatesInput>
    OR?: Enumerable<PROJECT_ACCESSIBILITYScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PROJECT_ACCESSIBILITYScalarWhereWithAggregatesInput>
    MEM_POS?: BigIntWithAggregatesFilter | bigint | number
    DEL_PJ?: StringNullableWithAggregatesFilter | string | null
    EDIT_MEM_POS?: StringNullableWithAggregatesFilter | string | null
    EDIT_MEM?: StringNullableWithAggregatesFilter | string | null
    EDIT_STATUS?: StringNullableWithAggregatesFilter | string | null
    CREATE_ANNOUNC_MNT?: StringNullableWithAggregatesFilter | string | null
  }

  export type PROJECT_INFOWhereInput = {
    AND?: Enumerable<PROJECT_INFOWhereInput>
    OR?: Enumerable<PROJECT_INFOWhereInput>
    NOT?: Enumerable<PROJECT_INFOWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    PJ_NAME?: StringNullableFilter | string | null
    PJ_CREATEDAY?: DateTimeNullableFilter | Date | string | null
    PJ_DEADLINE?: DateTimeNullableFilter | Date | string | null
    PJ_STATUS?: StringNullableFilter | string | null
    PJ_ADMIN?: BigIntNullableFilter | bigint | number | null
    PJ_OWNER?: StringNullableFilter | string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: XOR<PROJECT_MEMBERRelationFilter, PROJECT_MEMBERWhereInput> | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERListRelationFilter
    TASK_INFO?: TASK_INFOListRelationFilter
  }

  export type PROJECT_INFOOrderByWithRelationInput = {
    PJ_ID?: SortOrder
    PJ_NAME?: SortOrder
    PJ_CREATEDAY?: SortOrder
    PJ_DEADLINE?: SortOrder
    PJ_STATUS?: SortOrder
    PJ_ADMIN?: SortOrder
    PJ_OWNER?: SortOrder
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBEROrderByWithRelationInput
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBEROrderByRelationAggregateInput
    TASK_INFO?: TASK_INFOOrderByRelationAggregateInput
  }

  export type PROJECT_INFOWhereUniqueInput = {
    PJ_ID?: bigint | number
  }

  export type PROJECT_INFOOrderByWithAggregationInput = {
    PJ_ID?: SortOrder
    PJ_NAME?: SortOrder
    PJ_CREATEDAY?: SortOrder
    PJ_DEADLINE?: SortOrder
    PJ_STATUS?: SortOrder
    PJ_ADMIN?: SortOrder
    PJ_OWNER?: SortOrder
    _count?: PROJECT_INFOCountOrderByAggregateInput
    _avg?: PROJECT_INFOAvgOrderByAggregateInput
    _max?: PROJECT_INFOMaxOrderByAggregateInput
    _min?: PROJECT_INFOMinOrderByAggregateInput
    _sum?: PROJECT_INFOSumOrderByAggregateInput
  }

  export type PROJECT_INFOScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PROJECT_INFOScalarWhereWithAggregatesInput>
    OR?: Enumerable<PROJECT_INFOScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PROJECT_INFOScalarWhereWithAggregatesInput>
    PJ_ID?: BigIntWithAggregatesFilter | bigint | number
    PJ_NAME?: StringNullableWithAggregatesFilter | string | null
    PJ_CREATEDAY?: DateTimeNullableWithAggregatesFilter | Date | string | null
    PJ_DEADLINE?: DateTimeNullableWithAggregatesFilter | Date | string | null
    PJ_STATUS?: StringNullableWithAggregatesFilter | string | null
    PJ_ADMIN?: BigIntNullableWithAggregatesFilter | bigint | number | null
    PJ_OWNER?: StringNullableWithAggregatesFilter | string | null
  }

  export type PROJECT_MEMBERWhereInput = {
    AND?: Enumerable<PROJECT_MEMBERWhereInput>
    OR?: Enumerable<PROJECT_MEMBERWhereInput>
    NOT?: Enumerable<PROJECT_MEMBERWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    MEM_ID?: BigIntFilter | bigint | number
    MEM_POS?: BigIntNullableFilter | bigint | number | null
    USER_INFO?: XOR<USER_INFORelationFilter, USER_INFOWhereInput>
    PROJECT_ACCESSIBILITY?: XOR<PROJECT_ACCESSIBILITYRelationFilter, PROJECT_ACCESSIBILITYWhereInput> | null
    TASK_ACCESSIBILITY?: XOR<TASK_ACCESSIBILITYRelationFilter, TASK_ACCESSIBILITYWhereInput> | null
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: XOR<PROJECT_INFORelationFilter, PROJECT_INFOWhereInput>
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOListRelationFilter
    TASK_INFO?: TASK_INFOListRelationFilter
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEListRelationFilter
  }

  export type PROJECT_MEMBEROrderByWithRelationInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
    USER_INFO?: USER_INFOOrderByWithRelationInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYOrderByWithRelationInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYOrderByWithRelationInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOOrderByWithRelationInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOOrderByRelationAggregateInput
    TASK_INFO?: TASK_INFOOrderByRelationAggregateInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEOrderByRelationAggregateInput
  }

  export type PROJECT_MEMBERWhereUniqueInput = {
    PJ_ID_MEM_ID?: PROJECT_MEMBERPJ_IDMEM_IDCompoundUniqueInput
  }

  export type PROJECT_MEMBEROrderByWithAggregationInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
    _count?: PROJECT_MEMBERCountOrderByAggregateInput
    _avg?: PROJECT_MEMBERAvgOrderByAggregateInput
    _max?: PROJECT_MEMBERMaxOrderByAggregateInput
    _min?: PROJECT_MEMBERMinOrderByAggregateInput
    _sum?: PROJECT_MEMBERSumOrderByAggregateInput
  }

  export type PROJECT_MEMBERScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PROJECT_MEMBERScalarWhereWithAggregatesInput>
    OR?: Enumerable<PROJECT_MEMBERScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PROJECT_MEMBERScalarWhereWithAggregatesInput>
    PJ_ID?: BigIntWithAggregatesFilter | bigint | number
    MEM_ID?: BigIntWithAggregatesFilter | bigint | number
    MEM_POS?: BigIntNullableWithAggregatesFilter | bigint | number | null
  }

  export type TASK_ACCESSIBILITYWhereInput = {
    AND?: Enumerable<TASK_ACCESSIBILITYWhereInput>
    OR?: Enumerable<TASK_ACCESSIBILITYWhereInput>
    NOT?: Enumerable<TASK_ACCESSIBILITYWhereInput>
    MEM_POS?: BigIntFilter | bigint | number
    EDIT_MEM?: StringNullableFilter | string | null
    ADD_TASK?: StringNullableFilter | string | null
    DEL_TASK?: StringNullableFilter | string | null
    EDIT_NAME?: StringNullableFilter | string | null
    EDIT_DEADLINE?: StringNullableFilter | string | null
    EDIT_STATUS?: StringNullableFilter | string | null
    EDIT_DESCRIPTION?: StringNullableFilter | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERListRelationFilter
  }

  export type TASK_ACCESSIBILITYOrderByWithRelationInput = {
    MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    ADD_TASK?: SortOrder
    DEL_TASK?: SortOrder
    EDIT_NAME?: SortOrder
    EDIT_DEADLINE?: SortOrder
    EDIT_STATUS?: SortOrder
    EDIT_DESCRIPTION?: SortOrder
    PROJECT_MEMBER?: PROJECT_MEMBEROrderByRelationAggregateInput
  }

  export type TASK_ACCESSIBILITYWhereUniqueInput = {
    MEM_POS?: bigint | number
  }

  export type TASK_ACCESSIBILITYOrderByWithAggregationInput = {
    MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    ADD_TASK?: SortOrder
    DEL_TASK?: SortOrder
    EDIT_NAME?: SortOrder
    EDIT_DEADLINE?: SortOrder
    EDIT_STATUS?: SortOrder
    EDIT_DESCRIPTION?: SortOrder
    _count?: TASK_ACCESSIBILITYCountOrderByAggregateInput
    _avg?: TASK_ACCESSIBILITYAvgOrderByAggregateInput
    _max?: TASK_ACCESSIBILITYMaxOrderByAggregateInput
    _min?: TASK_ACCESSIBILITYMinOrderByAggregateInput
    _sum?: TASK_ACCESSIBILITYSumOrderByAggregateInput
  }

  export type TASK_ACCESSIBILITYScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TASK_ACCESSIBILITYScalarWhereWithAggregatesInput>
    OR?: Enumerable<TASK_ACCESSIBILITYScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TASK_ACCESSIBILITYScalarWhereWithAggregatesInput>
    MEM_POS?: BigIntWithAggregatesFilter | bigint | number
    EDIT_MEM?: StringNullableWithAggregatesFilter | string | null
    ADD_TASK?: StringNullableWithAggregatesFilter | string | null
    DEL_TASK?: StringNullableWithAggregatesFilter | string | null
    EDIT_NAME?: StringNullableWithAggregatesFilter | string | null
    EDIT_DEADLINE?: StringNullableWithAggregatesFilter | string | null
    EDIT_STATUS?: StringNullableWithAggregatesFilter | string | null
    EDIT_DESCRIPTION?: StringNullableWithAggregatesFilter | string | null
  }

  export type TASK_INFOWhereInput = {
    AND?: Enumerable<TASK_INFOWhereInput>
    OR?: Enumerable<TASK_INFOWhereInput>
    NOT?: Enumerable<TASK_INFOWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    TASK_ID?: BigIntFilter | bigint | number
    TASK_STATUS?: StringNullableFilter | string | null
    TASK_NAME?: StringNullableFilter | string | null
    TASK_DESCRIPTON?: StringNullableFilter | string | null
    TASK_CREATEDAY?: DateTimeNullableFilter | Date | string | null
    TASK_DEADLINE?: DateTimeNullableFilter | Date | string | null
    TASK_CREATOR?: BigIntNullableFilter | bigint | number | null
    PROJECT_INFO?: XOR<PROJECT_INFORelationFilter, PROJECT_INFOWhereInput>
    PROJECT_MEMBER?: XOR<PROJECT_MEMBERRelationFilter, PROJECT_MEMBERWhereInput> | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEListRelationFilter
  }

  export type TASK_INFOOrderByWithRelationInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_STATUS?: SortOrder
    TASK_NAME?: SortOrder
    TASK_DESCRIPTON?: SortOrder
    TASK_CREATEDAY?: SortOrder
    TASK_DEADLINE?: SortOrder
    TASK_CREATOR?: SortOrder
    PROJECT_INFO?: PROJECT_INFOOrderByWithRelationInput
    PROJECT_MEMBER?: PROJECT_MEMBEROrderByWithRelationInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEOrderByRelationAggregateInput
  }

  export type TASK_INFOWhereUniqueInput = {
    PJ_ID_TASK_ID?: TASK_INFOPJ_IDTASK_IDCompoundUniqueInput
  }

  export type TASK_INFOOrderByWithAggregationInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_STATUS?: SortOrder
    TASK_NAME?: SortOrder
    TASK_DESCRIPTON?: SortOrder
    TASK_CREATEDAY?: SortOrder
    TASK_DEADLINE?: SortOrder
    TASK_CREATOR?: SortOrder
    _count?: TASK_INFOCountOrderByAggregateInput
    _avg?: TASK_INFOAvgOrderByAggregateInput
    _max?: TASK_INFOMaxOrderByAggregateInput
    _min?: TASK_INFOMinOrderByAggregateInput
    _sum?: TASK_INFOSumOrderByAggregateInput
  }

  export type TASK_INFOScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TASK_INFOScalarWhereWithAggregatesInput>
    OR?: Enumerable<TASK_INFOScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TASK_INFOScalarWhereWithAggregatesInput>
    PJ_ID?: BigIntWithAggregatesFilter | bigint | number
    TASK_ID?: BigIntWithAggregatesFilter | bigint | number
    TASK_STATUS?: StringNullableWithAggregatesFilter | string | null
    TASK_NAME?: StringNullableWithAggregatesFilter | string | null
    TASK_DESCRIPTON?: StringNullableWithAggregatesFilter | string | null
    TASK_CREATEDAY?: DateTimeNullableWithAggregatesFilter | Date | string | null
    TASK_DEADLINE?: DateTimeNullableWithAggregatesFilter | Date | string | null
    TASK_CREATOR?: BigIntNullableWithAggregatesFilter | bigint | number | null
  }

  export type TASK_RESPONDSIPLEWhereInput = {
    AND?: Enumerable<TASK_RESPONDSIPLEWhereInput>
    OR?: Enumerable<TASK_RESPONDSIPLEWhereInput>
    NOT?: Enumerable<TASK_RESPONDSIPLEWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    TASK_ID?: BigIntFilter | bigint | number
    MEM_ID?: BigIntFilter | bigint | number
    PROJECT_MEMBER?: XOR<PROJECT_MEMBERRelationFilter, PROJECT_MEMBERWhereInput>
    TASK_INFO?: XOR<TASK_INFORelationFilter, TASK_INFOWhereInput>
  }

  export type TASK_RESPONDSIPLEOrderByWithRelationInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
    PROJECT_MEMBER?: PROJECT_MEMBEROrderByWithRelationInput
    TASK_INFO?: TASK_INFOOrderByWithRelationInput
  }

  export type TASK_RESPONDSIPLEWhereUniqueInput = {
    PJ_ID_TASK_ID_MEM_ID?: TASK_RESPONDSIPLEPJ_IDTASK_IDMEM_IDCompoundUniqueInput
  }

  export type TASK_RESPONDSIPLEOrderByWithAggregationInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
    _count?: TASK_RESPONDSIPLECountOrderByAggregateInput
    _avg?: TASK_RESPONDSIPLEAvgOrderByAggregateInput
    _max?: TASK_RESPONDSIPLEMaxOrderByAggregateInput
    _min?: TASK_RESPONDSIPLEMinOrderByAggregateInput
    _sum?: TASK_RESPONDSIPLESumOrderByAggregateInput
  }

  export type TASK_RESPONDSIPLEScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TASK_RESPONDSIPLEScalarWhereWithAggregatesInput>
    OR?: Enumerable<TASK_RESPONDSIPLEScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TASK_RESPONDSIPLEScalarWhereWithAggregatesInput>
    PJ_ID?: BigIntWithAggregatesFilter | bigint | number
    TASK_ID?: BigIntWithAggregatesFilter | bigint | number
    MEM_ID?: BigIntWithAggregatesFilter | bigint | number
  }

  export type USER_ACCOUNTCreateInput = {
    US_ID?: bigint | number
    US_ACCOUNT: string
    US_PASSWORD: string
    TOKEN?: string | null
    USER_INFO?: USER_INFOCreateNestedOneWithoutUSER_ACCOUNTInput
  }

  export type USER_ACCOUNTUncheckedCreateInput = {
    US_ID?: bigint | number
    US_ACCOUNT: string
    US_PASSWORD: string
    TOKEN?: string | null
    USER_INFO?: USER_INFOUncheckedCreateNestedOneWithoutUSER_ACCOUNTInput
  }

  export type USER_ACCOUNTUpdateInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_ACCOUNT?: StringFieldUpdateOperationsInput | string
    US_PASSWORD?: StringFieldUpdateOperationsInput | string
    TOKEN?: NullableStringFieldUpdateOperationsInput | string | null
    USER_INFO?: USER_INFOUpdateOneWithoutUSER_ACCOUNTNestedInput
  }

  export type USER_ACCOUNTUncheckedUpdateInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_ACCOUNT?: StringFieldUpdateOperationsInput | string
    US_PASSWORD?: StringFieldUpdateOperationsInput | string
    TOKEN?: NullableStringFieldUpdateOperationsInput | string | null
    USER_INFO?: USER_INFOUncheckedUpdateOneWithoutUSER_ACCOUNTNestedInput
  }

  export type USER_ACCOUNTCreateManyInput = {
    US_ID?: bigint | number
    US_ACCOUNT: string
    US_PASSWORD: string
    TOKEN?: string | null
  }

  export type USER_ACCOUNTUpdateManyMutationInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_ACCOUNT?: StringFieldUpdateOperationsInput | string
    US_PASSWORD?: StringFieldUpdateOperationsInput | string
    TOKEN?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USER_ACCOUNTUncheckedUpdateManyInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_ACCOUNT?: StringFieldUpdateOperationsInput | string
    US_PASSWORD?: StringFieldUpdateOperationsInput | string
    TOKEN?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USER_INFOCreateInput = {
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
    USER_ACCOUNT?: USER_ACCOUNTCreateNestedOneWithoutUSER_INFOInput
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedManyWithoutUSER_INFOInput
  }

  export type USER_INFOUncheckedCreateInput = {
    US_ID?: bigint | number
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutUSER_INFOInput
  }

  export type USER_INFOUpdateInput = {
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
    USER_ACCOUNT?: USER_ACCOUNTUpdateOneRequiredWithoutUSER_INFONestedInput
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateManyWithoutUSER_INFONestedInput
  }

  export type USER_INFOUncheckedUpdateInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedUpdateManyWithoutUSER_INFONestedInput
  }

  export type USER_INFOCreateManyInput = {
    US_ID?: bigint | number
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
  }

  export type USER_INFOUpdateManyMutationInput = {
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USER_INFOUncheckedUpdateManyInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_ACCESSIBILITYCreateInput = {
    MEM_POS: bigint | number
    DEL_PJ?: string | null
    EDIT_MEM_POS?: string | null
    EDIT_MEM?: string | null
    EDIT_STATUS?: string | null
    CREATE_ANNOUNC_MNT?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedManyWithoutPROJECT_ACCESSIBILITYInput
  }

  export type PROJECT_ACCESSIBILITYUncheckedCreateInput = {
    MEM_POS: bigint | number
    DEL_PJ?: string | null
    EDIT_MEM_POS?: string | null
    EDIT_MEM?: string | null
    EDIT_STATUS?: string | null
    CREATE_ANNOUNC_MNT?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutPROJECT_ACCESSIBILITYInput
  }

  export type PROJECT_ACCESSIBILITYUpdateInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    DEL_PJ?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM_POS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    CREATE_ANNOUNC_MNT?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateManyWithoutPROJECT_ACCESSIBILITYNestedInput
  }

  export type PROJECT_ACCESSIBILITYUncheckedUpdateInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    DEL_PJ?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM_POS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    CREATE_ANNOUNC_MNT?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_ACCESSIBILITYNestedInput
  }

  export type PROJECT_ACCESSIBILITYCreateManyInput = {
    MEM_POS: bigint | number
    DEL_PJ?: string | null
    EDIT_MEM_POS?: string | null
    EDIT_MEM?: string | null
    EDIT_STATUS?: string | null
    CREATE_ANNOUNC_MNT?: string | null
  }

  export type PROJECT_ACCESSIBILITYUpdateManyMutationInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    DEL_PJ?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM_POS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    CREATE_ANNOUNC_MNT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_ACCESSIBILITYUncheckedUpdateManyInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    DEL_PJ?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM_POS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    CREATE_ANNOUNC_MNT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_INFOCreateInput = {
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBERCreateNestedOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_INFOInput
  }

  export type PROJECT_INFOUncheckedCreateInput = {
    PJ_ID: bigint | number
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_ADMIN?: bigint | number | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_INFOInput
  }

  export type PROJECT_INFOUpdateInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBERUpdateOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_INFONestedInput
  }

  export type PROJECT_INFOUncheckedUpdateInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_ADMIN?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_INFONestedInput
  }

  export type PROJECT_INFOCreateManyInput = {
    PJ_ID: bigint | number
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_ADMIN?: bigint | number | null
    PJ_OWNER?: string | null
  }

  export type PROJECT_INFOUpdateManyMutationInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_INFOUncheckedUpdateManyInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_ADMIN?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_MEMBERCreateInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUpdateInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERCreateManyInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
  }

  export type PROJECT_MEMBERUpdateManyMutationInput = {

  }

  export type PROJECT_MEMBERUncheckedUpdateManyInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type TASK_ACCESSIBILITYCreateInput = {
    MEM_POS: bigint | number
    EDIT_MEM?: string | null
    ADD_TASK?: string | null
    DEL_TASK?: string | null
    EDIT_NAME?: string | null
    EDIT_DEADLINE?: string | null
    EDIT_STATUS?: string | null
    EDIT_DESCRIPTION?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedManyWithoutTASK_ACCESSIBILITYInput
  }

  export type TASK_ACCESSIBILITYUncheckedCreateInput = {
    MEM_POS: bigint | number
    EDIT_MEM?: string | null
    ADD_TASK?: string | null
    DEL_TASK?: string | null
    EDIT_NAME?: string | null
    EDIT_DEADLINE?: string | null
    EDIT_STATUS?: string | null
    EDIT_DESCRIPTION?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutTASK_ACCESSIBILITYInput
  }

  export type TASK_ACCESSIBILITYUpdateInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    ADD_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    DEL_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DEADLINE?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateManyWithoutTASK_ACCESSIBILITYNestedInput
  }

  export type TASK_ACCESSIBILITYUncheckedUpdateInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    ADD_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    DEL_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DEADLINE?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedUpdateManyWithoutTASK_ACCESSIBILITYNestedInput
  }

  export type TASK_ACCESSIBILITYCreateManyInput = {
    MEM_POS: bigint | number
    EDIT_MEM?: string | null
    ADD_TASK?: string | null
    DEL_TASK?: string | null
    EDIT_NAME?: string | null
    EDIT_DEADLINE?: string | null
    EDIT_STATUS?: string | null
    EDIT_DESCRIPTION?: string | null
  }

  export type TASK_ACCESSIBILITYUpdateManyMutationInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    ADD_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    DEL_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DEADLINE?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TASK_ACCESSIBILITYUncheckedUpdateManyInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    ADD_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    DEL_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DEADLINE?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TASK_INFOCreateInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    PROJECT_INFO: PROJECT_INFOCreateNestedOneWithoutTASK_INFOInput
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedOneWithoutTASK_INFOInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutTASK_INFOInput
  }

  export type TASK_INFOUncheckedCreateInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    TASK_CREATOR?: bigint | number | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutTASK_INFOInput
  }

  export type TASK_INFOUpdateInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PROJECT_INFO?: PROJECT_INFOUpdateOneRequiredWithoutTASK_INFONestedInput
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateOneWithoutTASK_INFONestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutTASK_INFONestedInput
  }

  export type TASK_INFOUncheckedUpdateInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_CREATOR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_INFONestedInput
  }

  export type TASK_INFOCreateManyInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    TASK_CREATOR?: bigint | number | null
  }

  export type TASK_INFOUpdateManyMutationInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TASK_INFOUncheckedUpdateManyInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_CREATOR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type TASK_RESPONDSIPLECreateInput = {
    PROJECT_MEMBER: PROJECT_MEMBERCreateNestedOneWithoutTASK_RESPONDSIPLEInput
    TASK_INFO: TASK_INFOCreateNestedOneWithoutTASK_RESPONDSIPLEInput
  }

  export type TASK_RESPONDSIPLEUncheckedCreateInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
    MEM_ID: bigint | number
  }

  export type TASK_RESPONDSIPLEUpdateInput = {
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateOneRequiredWithoutTASK_RESPONDSIPLENestedInput
    TASK_INFO?: TASK_INFOUpdateOneRequiredWithoutTASK_RESPONDSIPLENestedInput
  }

  export type TASK_RESPONDSIPLEUncheckedUpdateInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TASK_RESPONDSIPLECreateManyInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
    MEM_ID: bigint | number
  }

  export type TASK_RESPONDSIPLEUpdateManyMutationInput = {

  }

  export type TASK_RESPONDSIPLEUncheckedUpdateManyInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type USER_INFORelationFilter = {
    is?: USER_INFOWhereInput | null
    isNot?: USER_INFOWhereInput | null
  }

  export type USER_ACCOUNTCountOrderByAggregateInput = {
    US_ID?: SortOrder
    US_ACCOUNT?: SortOrder
    US_PASSWORD?: SortOrder
    TOKEN?: SortOrder
  }

  export type USER_ACCOUNTAvgOrderByAggregateInput = {
    US_ID?: SortOrder
  }

  export type USER_ACCOUNTMaxOrderByAggregateInput = {
    US_ID?: SortOrder
    US_ACCOUNT?: SortOrder
    US_PASSWORD?: SortOrder
    TOKEN?: SortOrder
  }

  export type USER_ACCOUNTMinOrderByAggregateInput = {
    US_ID?: SortOrder
    US_ACCOUNT?: SortOrder
    US_PASSWORD?: SortOrder
    TOKEN?: SortOrder
  }

  export type USER_ACCOUNTSumOrderByAggregateInput = {
    US_ID?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type USER_ACCOUNTRelationFilter = {
    is?: USER_ACCOUNTWhereInput
    isNot?: USER_ACCOUNTWhereInput
  }

  export type PROJECT_MEMBERListRelationFilter = {
    every?: PROJECT_MEMBERWhereInput
    some?: PROJECT_MEMBERWhereInput
    none?: PROJECT_MEMBERWhereInput
  }

  export type PROJECT_MEMBEROrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type USER_INFOCountOrderByAggregateInput = {
    US_ID?: SortOrder
    US_NAME?: SortOrder
    US_MAIL?: SortOrder
    US_PHONE?: SortOrder
    US_BIRTH?: SortOrder
    US_GENDER?: SortOrder
    US_ADDRESS?: SortOrder
  }

  export type USER_INFOAvgOrderByAggregateInput = {
    US_ID?: SortOrder
  }

  export type USER_INFOMaxOrderByAggregateInput = {
    US_ID?: SortOrder
    US_NAME?: SortOrder
    US_MAIL?: SortOrder
    US_PHONE?: SortOrder
    US_BIRTH?: SortOrder
    US_GENDER?: SortOrder
    US_ADDRESS?: SortOrder
  }

  export type USER_INFOMinOrderByAggregateInput = {
    US_ID?: SortOrder
    US_NAME?: SortOrder
    US_MAIL?: SortOrder
    US_PHONE?: SortOrder
    US_BIRTH?: SortOrder
    US_GENDER?: SortOrder
    US_ADDRESS?: SortOrder
  }

  export type USER_INFOSumOrderByAggregateInput = {
    US_ID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type PROJECT_ACCESSIBILITYCountOrderByAggregateInput = {
    MEM_POS?: SortOrder
    DEL_PJ?: SortOrder
    EDIT_MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    EDIT_STATUS?: SortOrder
    CREATE_ANNOUNC_MNT?: SortOrder
  }

  export type PROJECT_ACCESSIBILITYAvgOrderByAggregateInput = {
    MEM_POS?: SortOrder
  }

  export type PROJECT_ACCESSIBILITYMaxOrderByAggregateInput = {
    MEM_POS?: SortOrder
    DEL_PJ?: SortOrder
    EDIT_MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    EDIT_STATUS?: SortOrder
    CREATE_ANNOUNC_MNT?: SortOrder
  }

  export type PROJECT_ACCESSIBILITYMinOrderByAggregateInput = {
    MEM_POS?: SortOrder
    DEL_PJ?: SortOrder
    EDIT_MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    EDIT_STATUS?: SortOrder
    CREATE_ANNOUNC_MNT?: SortOrder
  }

  export type PROJECT_ACCESSIBILITYSumOrderByAggregateInput = {
    MEM_POS?: SortOrder
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type PROJECT_MEMBERRelationFilter = {
    is?: PROJECT_MEMBERWhereInput | null
    isNot?: PROJECT_MEMBERWhereInput | null
  }

  export type TASK_INFOListRelationFilter = {
    every?: TASK_INFOWhereInput
    some?: TASK_INFOWhereInput
    none?: TASK_INFOWhereInput
  }

  export type TASK_INFOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PROJECT_INFOCountOrderByAggregateInput = {
    PJ_ID?: SortOrder
    PJ_NAME?: SortOrder
    PJ_CREATEDAY?: SortOrder
    PJ_DEADLINE?: SortOrder
    PJ_STATUS?: SortOrder
    PJ_ADMIN?: SortOrder
    PJ_OWNER?: SortOrder
  }

  export type PROJECT_INFOAvgOrderByAggregateInput = {
    PJ_ID?: SortOrder
    PJ_ADMIN?: SortOrder
  }

  export type PROJECT_INFOMaxOrderByAggregateInput = {
    PJ_ID?: SortOrder
    PJ_NAME?: SortOrder
    PJ_CREATEDAY?: SortOrder
    PJ_DEADLINE?: SortOrder
    PJ_STATUS?: SortOrder
    PJ_ADMIN?: SortOrder
    PJ_OWNER?: SortOrder
  }

  export type PROJECT_INFOMinOrderByAggregateInput = {
    PJ_ID?: SortOrder
    PJ_NAME?: SortOrder
    PJ_CREATEDAY?: SortOrder
    PJ_DEADLINE?: SortOrder
    PJ_STATUS?: SortOrder
    PJ_ADMIN?: SortOrder
    PJ_OWNER?: SortOrder
  }

  export type PROJECT_INFOSumOrderByAggregateInput = {
    PJ_ID?: SortOrder
    PJ_ADMIN?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type PROJECT_ACCESSIBILITYRelationFilter = {
    is?: PROJECT_ACCESSIBILITYWhereInput | null
    isNot?: PROJECT_ACCESSIBILITYWhereInput | null
  }

  export type TASK_ACCESSIBILITYRelationFilter = {
    is?: TASK_ACCESSIBILITYWhereInput | null
    isNot?: TASK_ACCESSIBILITYWhereInput | null
  }

  export type PROJECT_INFORelationFilter = {
    is?: PROJECT_INFOWhereInput
    isNot?: PROJECT_INFOWhereInput
  }

  export type PROJECT_INFOListRelationFilter = {
    every?: PROJECT_INFOWhereInput
    some?: PROJECT_INFOWhereInput
    none?: PROJECT_INFOWhereInput
  }

  export type TASK_RESPONDSIPLEListRelationFilter = {
    every?: TASK_RESPONDSIPLEWhereInput
    some?: TASK_RESPONDSIPLEWhereInput
    none?: TASK_RESPONDSIPLEWhereInput
  }

  export type PROJECT_INFOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TASK_RESPONDSIPLEOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PROJECT_MEMBERPJ_IDMEM_IDCompoundUniqueInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
  }

  export type PROJECT_MEMBERCountOrderByAggregateInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
  }

  export type PROJECT_MEMBERAvgOrderByAggregateInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
  }

  export type PROJECT_MEMBERMaxOrderByAggregateInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
  }

  export type PROJECT_MEMBERMinOrderByAggregateInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
  }

  export type PROJECT_MEMBERSumOrderByAggregateInput = {
    PJ_ID?: SortOrder
    MEM_ID?: SortOrder
    MEM_POS?: SortOrder
  }

  export type TASK_ACCESSIBILITYCountOrderByAggregateInput = {
    MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    ADD_TASK?: SortOrder
    DEL_TASK?: SortOrder
    EDIT_NAME?: SortOrder
    EDIT_DEADLINE?: SortOrder
    EDIT_STATUS?: SortOrder
    EDIT_DESCRIPTION?: SortOrder
  }

  export type TASK_ACCESSIBILITYAvgOrderByAggregateInput = {
    MEM_POS?: SortOrder
  }

  export type TASK_ACCESSIBILITYMaxOrderByAggregateInput = {
    MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    ADD_TASK?: SortOrder
    DEL_TASK?: SortOrder
    EDIT_NAME?: SortOrder
    EDIT_DEADLINE?: SortOrder
    EDIT_STATUS?: SortOrder
    EDIT_DESCRIPTION?: SortOrder
  }

  export type TASK_ACCESSIBILITYMinOrderByAggregateInput = {
    MEM_POS?: SortOrder
    EDIT_MEM?: SortOrder
    ADD_TASK?: SortOrder
    DEL_TASK?: SortOrder
    EDIT_NAME?: SortOrder
    EDIT_DEADLINE?: SortOrder
    EDIT_STATUS?: SortOrder
    EDIT_DESCRIPTION?: SortOrder
  }

  export type TASK_ACCESSIBILITYSumOrderByAggregateInput = {
    MEM_POS?: SortOrder
  }

  export type TASK_INFOPJ_IDTASK_IDCompoundUniqueInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
  }

  export type TASK_INFOCountOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_STATUS?: SortOrder
    TASK_NAME?: SortOrder
    TASK_DESCRIPTON?: SortOrder
    TASK_CREATEDAY?: SortOrder
    TASK_DEADLINE?: SortOrder
    TASK_CREATOR?: SortOrder
  }

  export type TASK_INFOAvgOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_CREATOR?: SortOrder
  }

  export type TASK_INFOMaxOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_STATUS?: SortOrder
    TASK_NAME?: SortOrder
    TASK_DESCRIPTON?: SortOrder
    TASK_CREATEDAY?: SortOrder
    TASK_DEADLINE?: SortOrder
    TASK_CREATOR?: SortOrder
  }

  export type TASK_INFOMinOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_STATUS?: SortOrder
    TASK_NAME?: SortOrder
    TASK_DESCRIPTON?: SortOrder
    TASK_CREATEDAY?: SortOrder
    TASK_DEADLINE?: SortOrder
    TASK_CREATOR?: SortOrder
  }

  export type TASK_INFOSumOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    TASK_CREATOR?: SortOrder
  }

  export type TASK_INFORelationFilter = {
    is?: TASK_INFOWhereInput
    isNot?: TASK_INFOWhereInput
  }

  export type TASK_RESPONDSIPLEPJ_IDTASK_IDMEM_IDCompoundUniqueInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
    MEM_ID: bigint | number
  }

  export type TASK_RESPONDSIPLECountOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
  }

  export type TASK_RESPONDSIPLEAvgOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
  }

  export type TASK_RESPONDSIPLEMaxOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
  }

  export type TASK_RESPONDSIPLEMinOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
  }

  export type TASK_RESPONDSIPLESumOrderByAggregateInput = {
    PJ_ID?: SortOrder
    TASK_ID?: SortOrder
    MEM_ID?: SortOrder
  }

  export type USER_INFOCreateNestedOneWithoutUSER_ACCOUNTInput = {
    create?: XOR<USER_INFOCreateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput>
    connectOrCreate?: USER_INFOCreateOrConnectWithoutUSER_ACCOUNTInput
    connect?: USER_INFOWhereUniqueInput
  }

  export type USER_INFOUncheckedCreateNestedOneWithoutUSER_ACCOUNTInput = {
    create?: XOR<USER_INFOCreateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput>
    connectOrCreate?: USER_INFOCreateOrConnectWithoutUSER_ACCOUNTInput
    connect?: USER_INFOWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type USER_INFOUpdateOneWithoutUSER_ACCOUNTNestedInput = {
    create?: XOR<USER_INFOCreateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput>
    connectOrCreate?: USER_INFOCreateOrConnectWithoutUSER_ACCOUNTInput
    upsert?: USER_INFOUpsertWithoutUSER_ACCOUNTInput
    disconnect?: boolean
    delete?: boolean
    connect?: USER_INFOWhereUniqueInput
    update?: XOR<USER_INFOUpdateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedUpdateWithoutUSER_ACCOUNTInput>
  }

  export type USER_INFOUncheckedUpdateOneWithoutUSER_ACCOUNTNestedInput = {
    create?: XOR<USER_INFOCreateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput>
    connectOrCreate?: USER_INFOCreateOrConnectWithoutUSER_ACCOUNTInput
    upsert?: USER_INFOUpsertWithoutUSER_ACCOUNTInput
    disconnect?: boolean
    delete?: boolean
    connect?: USER_INFOWhereUniqueInput
    update?: XOR<USER_INFOUpdateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedUpdateWithoutUSER_ACCOUNTInput>
  }

  export type USER_ACCOUNTCreateNestedOneWithoutUSER_INFOInput = {
    create?: XOR<USER_ACCOUNTCreateWithoutUSER_INFOInput, USER_ACCOUNTUncheckedCreateWithoutUSER_INFOInput>
    connectOrCreate?: USER_ACCOUNTCreateOrConnectWithoutUSER_INFOInput
    connect?: USER_ACCOUNTWhereUniqueInput
  }

  export type PROJECT_MEMBERCreateNestedManyWithoutUSER_INFOInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutUSER_INFOInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutUSER_INFOInput>
    createMany?: PROJECT_MEMBERCreateManyUSER_INFOInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type PROJECT_MEMBERUncheckedCreateNestedManyWithoutUSER_INFOInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutUSER_INFOInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutUSER_INFOInput>
    createMany?: PROJECT_MEMBERCreateManyUSER_INFOInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type USER_ACCOUNTUpdateOneRequiredWithoutUSER_INFONestedInput = {
    create?: XOR<USER_ACCOUNTCreateWithoutUSER_INFOInput, USER_ACCOUNTUncheckedCreateWithoutUSER_INFOInput>
    connectOrCreate?: USER_ACCOUNTCreateOrConnectWithoutUSER_INFOInput
    upsert?: USER_ACCOUNTUpsertWithoutUSER_INFOInput
    connect?: USER_ACCOUNTWhereUniqueInput
    update?: XOR<USER_ACCOUNTUpdateWithoutUSER_INFOInput, USER_ACCOUNTUncheckedUpdateWithoutUSER_INFOInput>
  }

  export type PROJECT_MEMBERUpdateManyWithoutUSER_INFONestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutUSER_INFOInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutUSER_INFOInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutUSER_INFOInput>
    createMany?: PROJECT_MEMBERCreateManyUSER_INFOInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutUSER_INFOInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutUSER_INFOInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type PROJECT_MEMBERUncheckedUpdateManyWithoutUSER_INFONestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutUSER_INFOInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutUSER_INFOInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutUSER_INFOInput>
    createMany?: PROJECT_MEMBERCreateManyUSER_INFOInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutUSER_INFOInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutUSER_INFOInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type PROJECT_MEMBERCreateNestedManyWithoutPROJECT_ACCESSIBILITYInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type PROJECT_MEMBERUncheckedCreateNestedManyWithoutPROJECT_ACCESSIBILITYInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type PROJECT_MEMBERUpdateManyWithoutPROJECT_ACCESSIBILITYNestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_ACCESSIBILITYInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutPROJECT_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutPROJECT_ACCESSIBILITYInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutPROJECT_ACCESSIBILITYInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_ACCESSIBILITYNestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_ACCESSIBILITYInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutPROJECT_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutPROJECT_ACCESSIBILITYInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutPROJECT_ACCESSIBILITYInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type PROJECT_MEMBERCreateNestedOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    create?: XOR<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    connectOrCreate?: PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    connect?: PROJECT_MEMBERWhereUniqueInput
  }

  export type PROJECT_MEMBERCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type TASK_INFOCreateNestedManyWithoutPROJECT_INFOInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_INFOInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_INFOInput>
    createMany?: TASK_INFOCreateManyPROJECT_INFOInputEnvelope
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
  }

  export type PROJECT_MEMBERUncheckedCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_INFOInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_INFOInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_INFOInput>
    createMany?: TASK_INFOCreateManyPROJECT_INFOInputEnvelope
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
  }

  export type PROJECT_MEMBERUpdateOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput = {
    create?: XOR<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    connectOrCreate?: PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    upsert?: PROJECT_MEMBERUpsertWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    disconnect?: boolean
    delete?: boolean
    connect?: PROJECT_MEMBERWhereUniqueInput
    update?: XOR<PROJECT_MEMBERUpdateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_MEMBERUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type TASK_INFOUpdateManyWithoutPROJECT_INFONestedInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_INFOInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_INFOInput>
    upsert?: Enumerable<TASK_INFOUpsertWithWhereUniqueWithoutPROJECT_INFOInput>
    createMany?: TASK_INFOCreateManyPROJECT_INFOInputEnvelope
    set?: Enumerable<TASK_INFOWhereUniqueInput>
    disconnect?: Enumerable<TASK_INFOWhereUniqueInput>
    delete?: Enumerable<TASK_INFOWhereUniqueInput>
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
    update?: Enumerable<TASK_INFOUpdateWithWhereUniqueWithoutPROJECT_INFOInput>
    updateMany?: Enumerable<TASK_INFOUpdateManyWithWhereWithoutPROJECT_INFOInput>
    deleteMany?: Enumerable<TASK_INFOScalarWhereInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    createMany?: PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type TASK_INFOUncheckedUpdateManyWithoutPROJECT_INFONestedInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_INFOInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_INFOInput>
    upsert?: Enumerable<TASK_INFOUpsertWithWhereUniqueWithoutPROJECT_INFOInput>
    createMany?: TASK_INFOCreateManyPROJECT_INFOInputEnvelope
    set?: Enumerable<TASK_INFOWhereUniqueInput>
    disconnect?: Enumerable<TASK_INFOWhereUniqueInput>
    delete?: Enumerable<TASK_INFOWhereUniqueInput>
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
    update?: Enumerable<TASK_INFOUpdateWithWhereUniqueWithoutPROJECT_INFOInput>
    updateMany?: Enumerable<TASK_INFOUpdateManyWithWhereWithoutPROJECT_INFOInput>
    deleteMany?: Enumerable<TASK_INFOScalarWhereInput>
  }

  export type USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput = {
    create?: XOR<USER_INFOCreateWithoutPROJECT_MEMBERInput, USER_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>
    connectOrCreate?: USER_INFOCreateOrConnectWithoutPROJECT_MEMBERInput
    connect?: USER_INFOWhereUniqueInput
  }

  export type PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput = {
    create?: XOR<PROJECT_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, PROJECT_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
    connectOrCreate?: PROJECT_ACCESSIBILITYCreateOrConnectWithoutPROJECT_MEMBERInput
    connect?: PROJECT_ACCESSIBILITYWhereUniqueInput
  }

  export type TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput = {
    create?: XOR<TASK_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, TASK_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
    connectOrCreate?: TASK_ACCESSIBILITYCreateOrConnectWithoutPROJECT_MEMBERInput
    connect?: TASK_ACCESSIBILITYWhereUniqueInput
  }

  export type PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    create?: XOR<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    connectOrCreate?: PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    connect?: PROJECT_INFOWhereUniqueInput
  }

  export type PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    create?: XOR<Enumerable<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>, Enumerable<PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    createMany?: PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInputEnvelope
    connect?: Enumerable<PROJECT_INFOWhereUniqueInput>
  }

  export type TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_MEMBERInput>
    createMany?: TASK_INFOCreateManyPROJECT_MEMBERInputEnvelope
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
  }

  export type TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutPROJECT_MEMBERInput>
    createMany?: TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInputEnvelope
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
  }

  export type PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    create?: XOR<Enumerable<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>, Enumerable<PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    createMany?: PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInputEnvelope
    connect?: Enumerable<PROJECT_INFOWhereUniqueInput>
  }

  export type TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_MEMBERInput>
    createMany?: TASK_INFOCreateManyPROJECT_MEMBERInputEnvelope
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
  }

  export type TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutPROJECT_MEMBERInput>
    createMany?: TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInputEnvelope
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
  }

  export type USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<USER_INFOCreateWithoutPROJECT_MEMBERInput, USER_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>
    connectOrCreate?: USER_INFOCreateOrConnectWithoutPROJECT_MEMBERInput
    upsert?: USER_INFOUpsertWithoutPROJECT_MEMBERInput
    connect?: USER_INFOWhereUniqueInput
    update?: XOR<USER_INFOUpdateWithoutPROJECT_MEMBERInput, USER_INFOUncheckedUpdateWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<PROJECT_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, PROJECT_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
    connectOrCreate?: PROJECT_ACCESSIBILITYCreateOrConnectWithoutPROJECT_MEMBERInput
    upsert?: PROJECT_ACCESSIBILITYUpsertWithoutPROJECT_MEMBERInput
    disconnect?: boolean
    delete?: boolean
    connect?: PROJECT_ACCESSIBILITYWhereUniqueInput
    update?: XOR<PROJECT_ACCESSIBILITYUpdateWithoutPROJECT_MEMBERInput, PROJECT_ACCESSIBILITYUncheckedUpdateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<TASK_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, TASK_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
    connectOrCreate?: TASK_ACCESSIBILITYCreateOrConnectWithoutPROJECT_MEMBERInput
    upsert?: TASK_ACCESSIBILITYUpsertWithoutPROJECT_MEMBERInput
    disconnect?: boolean
    delete?: boolean
    connect?: TASK_ACCESSIBILITYWhereUniqueInput
    update?: XOR<TASK_ACCESSIBILITYUpdateWithoutPROJECT_MEMBERInput, TASK_ACCESSIBILITYUncheckedUpdateWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput = {
    create?: XOR<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    connectOrCreate?: PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    upsert?: PROJECT_INFOUpsertWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    connect?: PROJECT_INFOWhereUniqueInput
    update?: XOR<PROJECT_INFOUpdateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_INFOUncheckedUpdateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput = {
    create?: XOR<Enumerable<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>, Enumerable<PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    upsert?: Enumerable<PROJECT_INFOUpsertWithWhereUniqueWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    createMany?: PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInputEnvelope
    set?: Enumerable<PROJECT_INFOWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_INFOWhereUniqueInput>
    delete?: Enumerable<PROJECT_INFOWhereUniqueInput>
    connect?: Enumerable<PROJECT_INFOWhereUniqueInput>
    update?: Enumerable<PROJECT_INFOUpdateWithWhereUniqueWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    updateMany?: Enumerable<PROJECT_INFOUpdateManyWithWhereWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    deleteMany?: Enumerable<PROJECT_INFOScalarWhereInput>
  }

  export type TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_MEMBERInput>
    upsert?: Enumerable<TASK_INFOUpsertWithWhereUniqueWithoutPROJECT_MEMBERInput>
    createMany?: TASK_INFOCreateManyPROJECT_MEMBERInputEnvelope
    set?: Enumerable<TASK_INFOWhereUniqueInput>
    disconnect?: Enumerable<TASK_INFOWhereUniqueInput>
    delete?: Enumerable<TASK_INFOWhereUniqueInput>
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
    update?: Enumerable<TASK_INFOUpdateWithWhereUniqueWithoutPROJECT_MEMBERInput>
    updateMany?: Enumerable<TASK_INFOUpdateManyWithWhereWithoutPROJECT_MEMBERInput>
    deleteMany?: Enumerable<TASK_INFOScalarWhereInput>
  }

  export type TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutPROJECT_MEMBERInput>
    upsert?: Enumerable<TASK_RESPONDSIPLEUpsertWithWhereUniqueWithoutPROJECT_MEMBERInput>
    createMany?: TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInputEnvelope
    set?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    disconnect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    delete?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    update?: Enumerable<TASK_RESPONDSIPLEUpdateWithWhereUniqueWithoutPROJECT_MEMBERInput>
    updateMany?: Enumerable<TASK_RESPONDSIPLEUpdateManyWithWhereWithoutPROJECT_MEMBERInput>
    deleteMany?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
  }

  export type PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput = {
    create?: XOR<Enumerable<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>, Enumerable<PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    upsert?: Enumerable<PROJECT_INFOUpsertWithWhereUniqueWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    createMany?: PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInputEnvelope
    set?: Enumerable<PROJECT_INFOWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_INFOWhereUniqueInput>
    delete?: Enumerable<PROJECT_INFOWhereUniqueInput>
    connect?: Enumerable<PROJECT_INFOWhereUniqueInput>
    update?: Enumerable<PROJECT_INFOUpdateWithWhereUniqueWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    updateMany?: Enumerable<PROJECT_INFOUpdateManyWithWhereWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    deleteMany?: Enumerable<PROJECT_INFOScalarWhereInput>
  }

  export type TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<Enumerable<TASK_INFOCreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_INFOCreateOrConnectWithoutPROJECT_MEMBERInput>
    upsert?: Enumerable<TASK_INFOUpsertWithWhereUniqueWithoutPROJECT_MEMBERInput>
    createMany?: TASK_INFOCreateManyPROJECT_MEMBERInputEnvelope
    set?: Enumerable<TASK_INFOWhereUniqueInput>
    disconnect?: Enumerable<TASK_INFOWhereUniqueInput>
    delete?: Enumerable<TASK_INFOWhereUniqueInput>
    connect?: Enumerable<TASK_INFOWhereUniqueInput>
    update?: Enumerable<TASK_INFOUpdateWithWhereUniqueWithoutPROJECT_MEMBERInput>
    updateMany?: Enumerable<TASK_INFOUpdateManyWithWhereWithoutPROJECT_MEMBERInput>
    deleteMany?: Enumerable<TASK_INFOScalarWhereInput>
  }

  export type TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutPROJECT_MEMBERInput>
    upsert?: Enumerable<TASK_RESPONDSIPLEUpsertWithWhereUniqueWithoutPROJECT_MEMBERInput>
    createMany?: TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInputEnvelope
    set?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    disconnect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    delete?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    update?: Enumerable<TASK_RESPONDSIPLEUpdateWithWhereUniqueWithoutPROJECT_MEMBERInput>
    updateMany?: Enumerable<TASK_RESPONDSIPLEUpdateManyWithWhereWithoutPROJECT_MEMBERInput>
    deleteMany?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
  }

  export type PROJECT_MEMBERCreateNestedManyWithoutTASK_ACCESSIBILITYInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutTASK_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type PROJECT_MEMBERUncheckedCreateNestedManyWithoutTASK_ACCESSIBILITYInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutTASK_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInputEnvelope
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
  }

  export type PROJECT_MEMBERUpdateManyWithoutTASK_ACCESSIBILITYNestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutTASK_ACCESSIBILITYInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutTASK_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutTASK_ACCESSIBILITYInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutTASK_ACCESSIBILITYInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type PROJECT_MEMBERUncheckedUpdateManyWithoutTASK_ACCESSIBILITYNestedInput = {
    create?: XOR<Enumerable<PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput>, Enumerable<PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput>>
    connectOrCreate?: Enumerable<PROJECT_MEMBERCreateOrConnectWithoutTASK_ACCESSIBILITYInput>
    upsert?: Enumerable<PROJECT_MEMBERUpsertWithWhereUniqueWithoutTASK_ACCESSIBILITYInput>
    createMany?: PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInputEnvelope
    set?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    disconnect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    delete?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    connect?: Enumerable<PROJECT_MEMBERWhereUniqueInput>
    update?: Enumerable<PROJECT_MEMBERUpdateWithWhereUniqueWithoutTASK_ACCESSIBILITYInput>
    updateMany?: Enumerable<PROJECT_MEMBERUpdateManyWithWhereWithoutTASK_ACCESSIBILITYInput>
    deleteMany?: Enumerable<PROJECT_MEMBERScalarWhereInput>
  }

  export type PROJECT_INFOCreateNestedOneWithoutTASK_INFOInput = {
    create?: XOR<PROJECT_INFOCreateWithoutTASK_INFOInput, PROJECT_INFOUncheckedCreateWithoutTASK_INFOInput>
    connectOrCreate?: PROJECT_INFOCreateOrConnectWithoutTASK_INFOInput
    connect?: PROJECT_INFOWhereUniqueInput
  }

  export type PROJECT_MEMBERCreateNestedOneWithoutTASK_INFOInput = {
    create?: XOR<PROJECT_MEMBERCreateWithoutTASK_INFOInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_INFOInput>
    connectOrCreate?: PROJECT_MEMBERCreateOrConnectWithoutTASK_INFOInput
    connect?: PROJECT_MEMBERWhereUniqueInput
  }

  export type TASK_RESPONDSIPLECreateNestedManyWithoutTASK_INFOInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutTASK_INFOInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutTASK_INFOInput>
    createMany?: TASK_RESPONDSIPLECreateManyTASK_INFOInputEnvelope
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
  }

  export type TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutTASK_INFOInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutTASK_INFOInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutTASK_INFOInput>
    createMany?: TASK_RESPONDSIPLECreateManyTASK_INFOInputEnvelope
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
  }

  export type PROJECT_INFOUpdateOneRequiredWithoutTASK_INFONestedInput = {
    create?: XOR<PROJECT_INFOCreateWithoutTASK_INFOInput, PROJECT_INFOUncheckedCreateWithoutTASK_INFOInput>
    connectOrCreate?: PROJECT_INFOCreateOrConnectWithoutTASK_INFOInput
    upsert?: PROJECT_INFOUpsertWithoutTASK_INFOInput
    connect?: PROJECT_INFOWhereUniqueInput
    update?: XOR<PROJECT_INFOUpdateWithoutTASK_INFOInput, PROJECT_INFOUncheckedUpdateWithoutTASK_INFOInput>
  }

  export type PROJECT_MEMBERUpdateOneWithoutTASK_INFONestedInput = {
    create?: XOR<PROJECT_MEMBERCreateWithoutTASK_INFOInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_INFOInput>
    connectOrCreate?: PROJECT_MEMBERCreateOrConnectWithoutTASK_INFOInput
    upsert?: PROJECT_MEMBERUpsertWithoutTASK_INFOInput
    disconnect?: boolean
    delete?: boolean
    connect?: PROJECT_MEMBERWhereUniqueInput
    update?: XOR<PROJECT_MEMBERUpdateWithoutTASK_INFOInput, PROJECT_MEMBERUncheckedUpdateWithoutTASK_INFOInput>
  }

  export type TASK_RESPONDSIPLEUpdateManyWithoutTASK_INFONestedInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutTASK_INFOInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutTASK_INFOInput>
    upsert?: Enumerable<TASK_RESPONDSIPLEUpsertWithWhereUniqueWithoutTASK_INFOInput>
    createMany?: TASK_RESPONDSIPLECreateManyTASK_INFOInputEnvelope
    set?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    disconnect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    delete?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    update?: Enumerable<TASK_RESPONDSIPLEUpdateWithWhereUniqueWithoutTASK_INFOInput>
    updateMany?: Enumerable<TASK_RESPONDSIPLEUpdateManyWithWhereWithoutTASK_INFOInput>
    deleteMany?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
  }

  export type TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_INFONestedInput = {
    create?: XOR<Enumerable<TASK_RESPONDSIPLECreateWithoutTASK_INFOInput>, Enumerable<TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput>>
    connectOrCreate?: Enumerable<TASK_RESPONDSIPLECreateOrConnectWithoutTASK_INFOInput>
    upsert?: Enumerable<TASK_RESPONDSIPLEUpsertWithWhereUniqueWithoutTASK_INFOInput>
    createMany?: TASK_RESPONDSIPLECreateManyTASK_INFOInputEnvelope
    set?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    disconnect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    delete?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    connect?: Enumerable<TASK_RESPONDSIPLEWhereUniqueInput>
    update?: Enumerable<TASK_RESPONDSIPLEUpdateWithWhereUniqueWithoutTASK_INFOInput>
    updateMany?: Enumerable<TASK_RESPONDSIPLEUpdateManyWithWhereWithoutTASK_INFOInput>
    deleteMany?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
  }

  export type PROJECT_MEMBERCreateNestedOneWithoutTASK_RESPONDSIPLEInput = {
    create?: XOR<PROJECT_MEMBERCreateWithoutTASK_RESPONDSIPLEInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
    connectOrCreate?: PROJECT_MEMBERCreateOrConnectWithoutTASK_RESPONDSIPLEInput
    connect?: PROJECT_MEMBERWhereUniqueInput
  }

  export type TASK_INFOCreateNestedOneWithoutTASK_RESPONDSIPLEInput = {
    create?: XOR<TASK_INFOCreateWithoutTASK_RESPONDSIPLEInput, TASK_INFOUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
    connectOrCreate?: TASK_INFOCreateOrConnectWithoutTASK_RESPONDSIPLEInput
    connect?: TASK_INFOWhereUniqueInput
  }

  export type PROJECT_MEMBERUpdateOneRequiredWithoutTASK_RESPONDSIPLENestedInput = {
    create?: XOR<PROJECT_MEMBERCreateWithoutTASK_RESPONDSIPLEInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
    connectOrCreate?: PROJECT_MEMBERCreateOrConnectWithoutTASK_RESPONDSIPLEInput
    upsert?: PROJECT_MEMBERUpsertWithoutTASK_RESPONDSIPLEInput
    connect?: PROJECT_MEMBERWhereUniqueInput
    update?: XOR<PROJECT_MEMBERUpdateWithoutTASK_RESPONDSIPLEInput, PROJECT_MEMBERUncheckedUpdateWithoutTASK_RESPONDSIPLEInput>
  }

  export type TASK_INFOUpdateOneRequiredWithoutTASK_RESPONDSIPLENestedInput = {
    create?: XOR<TASK_INFOCreateWithoutTASK_RESPONDSIPLEInput, TASK_INFOUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
    connectOrCreate?: TASK_INFOCreateOrConnectWithoutTASK_RESPONDSIPLEInput
    upsert?: TASK_INFOUpsertWithoutTASK_RESPONDSIPLEInput
    connect?: TASK_INFOWhereUniqueInput
    update?: XOR<TASK_INFOUpdateWithoutTASK_RESPONDSIPLEInput, TASK_INFOUncheckedUpdateWithoutTASK_RESPONDSIPLEInput>
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type USER_INFOCreateWithoutUSER_ACCOUNTInput = {
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedManyWithoutUSER_INFOInput
  }

  export type USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput = {
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutUSER_INFOInput
  }

  export type USER_INFOCreateOrConnectWithoutUSER_ACCOUNTInput = {
    where: USER_INFOWhereUniqueInput
    create: XOR<USER_INFOCreateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput>
  }

  export type USER_INFOUpsertWithoutUSER_ACCOUNTInput = {
    update: XOR<USER_INFOUpdateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedUpdateWithoutUSER_ACCOUNTInput>
    create: XOR<USER_INFOCreateWithoutUSER_ACCOUNTInput, USER_INFOUncheckedCreateWithoutUSER_ACCOUNTInput>
  }

  export type USER_INFOUpdateWithoutUSER_ACCOUNTInput = {
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateManyWithoutUSER_INFONestedInput
  }

  export type USER_INFOUncheckedUpdateWithoutUSER_ACCOUNTInput = {
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUncheckedUpdateManyWithoutUSER_INFONestedInput
  }

  export type USER_ACCOUNTCreateWithoutUSER_INFOInput = {
    US_ID?: bigint | number
    US_ACCOUNT: string
    US_PASSWORD: string
    TOKEN?: string | null
  }

  export type USER_ACCOUNTUncheckedCreateWithoutUSER_INFOInput = {
    US_ID?: bigint | number
    US_ACCOUNT: string
    US_PASSWORD: string
    TOKEN?: string | null
  }

  export type USER_ACCOUNTCreateOrConnectWithoutUSER_INFOInput = {
    where: USER_ACCOUNTWhereUniqueInput
    create: XOR<USER_ACCOUNTCreateWithoutUSER_INFOInput, USER_ACCOUNTUncheckedCreateWithoutUSER_INFOInput>
  }

  export type PROJECT_MEMBERCreateWithoutUSER_INFOInput = {
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput = {
    PJ_ID: bigint | number
    MEM_POS?: bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutUSER_INFOInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutUSER_INFOInput, PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput>
  }

  export type PROJECT_MEMBERCreateManyUSER_INFOInputEnvelope = {
    data: Enumerable<PROJECT_MEMBERCreateManyUSER_INFOInput>
    skipDuplicates?: boolean
  }

  export type USER_ACCOUNTUpsertWithoutUSER_INFOInput = {
    update: XOR<USER_ACCOUNTUpdateWithoutUSER_INFOInput, USER_ACCOUNTUncheckedUpdateWithoutUSER_INFOInput>
    create: XOR<USER_ACCOUNTCreateWithoutUSER_INFOInput, USER_ACCOUNTUncheckedCreateWithoutUSER_INFOInput>
  }

  export type USER_ACCOUNTUpdateWithoutUSER_INFOInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_ACCOUNT?: StringFieldUpdateOperationsInput | string
    US_PASSWORD?: StringFieldUpdateOperationsInput | string
    TOKEN?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USER_ACCOUNTUncheckedUpdateWithoutUSER_INFOInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_ACCOUNT?: StringFieldUpdateOperationsInput | string
    US_PASSWORD?: StringFieldUpdateOperationsInput | string
    TOKEN?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_MEMBERUpsertWithWhereUniqueWithoutUSER_INFOInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    update: XOR<PROJECT_MEMBERUpdateWithoutUSER_INFOInput, PROJECT_MEMBERUncheckedUpdateWithoutUSER_INFOInput>
    create: XOR<PROJECT_MEMBERCreateWithoutUSER_INFOInput, PROJECT_MEMBERUncheckedCreateWithoutUSER_INFOInput>
  }

  export type PROJECT_MEMBERUpdateWithWhereUniqueWithoutUSER_INFOInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    data: XOR<PROJECT_MEMBERUpdateWithoutUSER_INFOInput, PROJECT_MEMBERUncheckedUpdateWithoutUSER_INFOInput>
  }

  export type PROJECT_MEMBERUpdateManyWithWhereWithoutUSER_INFOInput = {
    where: PROJECT_MEMBERScalarWhereInput
    data: XOR<PROJECT_MEMBERUpdateManyMutationInput, PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_MEMBERScalarWhereInput = {
    AND?: Enumerable<PROJECT_MEMBERScalarWhereInput>
    OR?: Enumerable<PROJECT_MEMBERScalarWhereInput>
    NOT?: Enumerable<PROJECT_MEMBERScalarWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    MEM_ID?: BigIntFilter | bigint | number
    MEM_POS?: BigIntNullableFilter | bigint | number | null
  }

  export type PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutPROJECT_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput>
  }

  export type PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInputEnvelope = {
    data: Enumerable<PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInput>
    skipDuplicates?: boolean
  }

  export type PROJECT_MEMBERUpsertWithWhereUniqueWithoutPROJECT_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    update: XOR<PROJECT_MEMBERUpdateWithoutPROJECT_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_ACCESSIBILITYInput>
    create: XOR<PROJECT_MEMBERCreateWithoutPROJECT_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_ACCESSIBILITYInput>
  }

  export type PROJECT_MEMBERUpdateWithWhereUniqueWithoutPROJECT_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    data: XOR<PROJECT_MEMBERUpdateWithoutPROJECT_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_ACCESSIBILITYInput>
  }

  export type PROJECT_MEMBERUpdateManyWithWhereWithoutPROJECT_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERScalarWhereInput
    data: XOR<PROJECT_MEMBERUpdateManyMutationInput, PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInputEnvelope = {
    data: Enumerable<PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    skipDuplicates?: boolean
  }

  export type TASK_INFOCreateWithoutPROJECT_INFOInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedOneWithoutTASK_INFOInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutTASK_INFOInput
  }

  export type TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    TASK_CREATOR?: bigint | number | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutTASK_INFOInput
  }

  export type TASK_INFOCreateOrConnectWithoutPROJECT_INFOInput = {
    where: TASK_INFOWhereUniqueInput
    create: XOR<TASK_INFOCreateWithoutPROJECT_INFOInput, TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput>
  }

  export type TASK_INFOCreateManyPROJECT_INFOInputEnvelope = {
    data: Enumerable<TASK_INFOCreateManyPROJECT_INFOInput>
    skipDuplicates?: boolean
  }

  export type PROJECT_MEMBERUpsertWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    update: XOR<PROJECT_MEMBERUpdateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    create: XOR<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_MEMBERUpdateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUpsertWithWhereUniqueWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    update: XOR<PROJECT_MEMBERUpdateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    create: XOR<PROJECT_MEMBERCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_MEMBERUncheckedCreateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type PROJECT_MEMBERUpdateWithWhereUniqueWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    data: XOR<PROJECT_MEMBERUpdateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type PROJECT_MEMBERUpdateManyWithWhereWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    where: PROJECT_MEMBERScalarWhereInput
    data: XOR<PROJECT_MEMBERUpdateManyMutationInput, PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type TASK_INFOUpsertWithWhereUniqueWithoutPROJECT_INFOInput = {
    where: TASK_INFOWhereUniqueInput
    update: XOR<TASK_INFOUpdateWithoutPROJECT_INFOInput, TASK_INFOUncheckedUpdateWithoutPROJECT_INFOInput>
    create: XOR<TASK_INFOCreateWithoutPROJECT_INFOInput, TASK_INFOUncheckedCreateWithoutPROJECT_INFOInput>
  }

  export type TASK_INFOUpdateWithWhereUniqueWithoutPROJECT_INFOInput = {
    where: TASK_INFOWhereUniqueInput
    data: XOR<TASK_INFOUpdateWithoutPROJECT_INFOInput, TASK_INFOUncheckedUpdateWithoutPROJECT_INFOInput>
  }

  export type TASK_INFOUpdateManyWithWhereWithoutPROJECT_INFOInput = {
    where: TASK_INFOScalarWhereInput
    data: XOR<TASK_INFOUpdateManyMutationInput, TASK_INFOUncheckedUpdateManyWithoutTASK_INFOInput>
  }

  export type TASK_INFOScalarWhereInput = {
    AND?: Enumerable<TASK_INFOScalarWhereInput>
    OR?: Enumerable<TASK_INFOScalarWhereInput>
    NOT?: Enumerable<TASK_INFOScalarWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    TASK_ID?: BigIntFilter | bigint | number
    TASK_STATUS?: StringNullableFilter | string | null
    TASK_NAME?: StringNullableFilter | string | null
    TASK_DESCRIPTON?: StringNullableFilter | string | null
    TASK_CREATEDAY?: DateTimeNullableFilter | Date | string | null
    TASK_DEADLINE?: DateTimeNullableFilter | Date | string | null
    TASK_CREATOR?: BigIntNullableFilter | bigint | number | null
  }

  export type USER_INFOCreateWithoutPROJECT_MEMBERInput = {
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
    USER_ACCOUNT?: USER_ACCOUNTCreateNestedOneWithoutUSER_INFOInput
  }

  export type USER_INFOUncheckedCreateWithoutPROJECT_MEMBERInput = {
    US_ID?: bigint | number
    US_NAME?: string | null
    US_MAIL?: string | null
    US_PHONE?: string | null
    US_BIRTH?: Date | string | null
    US_GENDER?: string | null
    US_ADDRESS?: string | null
  }

  export type USER_INFOCreateOrConnectWithoutPROJECT_MEMBERInput = {
    where: USER_INFOWhereUniqueInput
    create: XOR<USER_INFOCreateWithoutPROJECT_MEMBERInput, USER_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput = {
    MEM_POS: bigint | number
    DEL_PJ?: string | null
    EDIT_MEM_POS?: string | null
    EDIT_MEM?: string | null
    EDIT_STATUS?: string | null
    CREATE_ANNOUNC_MNT?: string | null
  }

  export type PROJECT_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput = {
    MEM_POS: bigint | number
    DEL_PJ?: string | null
    EDIT_MEM_POS?: string | null
    EDIT_MEM?: string | null
    EDIT_STATUS?: string | null
    CREATE_ANNOUNC_MNT?: string | null
  }

  export type PROJECT_ACCESSIBILITYCreateOrConnectWithoutPROJECT_MEMBERInput = {
    where: PROJECT_ACCESSIBILITYWhereUniqueInput
    create: XOR<PROJECT_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, PROJECT_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput = {
    MEM_POS: bigint | number
    EDIT_MEM?: string | null
    ADD_TASK?: string | null
    DEL_TASK?: string | null
    EDIT_NAME?: string | null
    EDIT_DEADLINE?: string | null
    EDIT_STATUS?: string | null
    EDIT_DESCRIPTION?: string | null
  }

  export type TASK_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput = {
    MEM_POS: bigint | number
    EDIT_MEM?: string | null
    ADD_TASK?: string | null
    DEL_TASK?: string | null
    EDIT_NAME?: string | null
    EDIT_DEADLINE?: string | null
    EDIT_STATUS?: string | null
    EDIT_DESCRIPTION?: string | null
  }

  export type TASK_ACCESSIBILITYCreateOrConnectWithoutPROJECT_MEMBERInput = {
    where: TASK_ACCESSIBILITYWhereUniqueInput
    create: XOR<TASK_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, TASK_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBERCreateNestedOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_INFOInput
  }

  export type PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    PJ_ID: bigint | number
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_ADMIN?: bigint | number | null
    PJ_OWNER?: string | null
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_INFOInput
  }

  export type PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    where: PROJECT_INFOWhereUniqueInput
    create: XOR<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_INFOInput
  }

  export type PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_INFOInput
  }

  export type PROJECT_INFOCreateOrConnectWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    where: PROJECT_INFOWhereUniqueInput
    create: XOR<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInputEnvelope = {
    data: Enumerable<PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    skipDuplicates?: boolean
  }

  export type TASK_INFOCreateWithoutPROJECT_MEMBERInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    PROJECT_INFO: PROJECT_INFOCreateNestedOneWithoutTASK_INFOInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutTASK_INFOInput
  }

  export type TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutTASK_INFOInput
  }

  export type TASK_INFOCreateOrConnectWithoutPROJECT_MEMBERInput = {
    where: TASK_INFOWhereUniqueInput
    create: XOR<TASK_INFOCreateWithoutPROJECT_MEMBERInput, TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_INFOCreateManyPROJECT_MEMBERInputEnvelope = {
    data: Enumerable<TASK_INFOCreateManyPROJECT_MEMBERInput>
    skipDuplicates?: boolean
  }

  export type TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput = {
    TASK_INFO: TASK_INFOCreateNestedOneWithoutTASK_RESPONDSIPLEInput
  }

  export type TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput = {
    TASK_ID: bigint | number
  }

  export type TASK_RESPONDSIPLECreateOrConnectWithoutPROJECT_MEMBERInput = {
    where: TASK_RESPONDSIPLEWhereUniqueInput
    create: XOR<TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput, TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInputEnvelope = {
    data: Enumerable<TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInput>
    skipDuplicates?: boolean
  }

  export type USER_INFOUpsertWithoutPROJECT_MEMBERInput = {
    update: XOR<USER_INFOUpdateWithoutPROJECT_MEMBERInput, USER_INFOUncheckedUpdateWithoutPROJECT_MEMBERInput>
    create: XOR<USER_INFOCreateWithoutPROJECT_MEMBERInput, USER_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type USER_INFOUpdateWithoutPROJECT_MEMBERInput = {
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
    USER_ACCOUNT?: USER_ACCOUNTUpdateOneRequiredWithoutUSER_INFONestedInput
  }

  export type USER_INFOUncheckedUpdateWithoutPROJECT_MEMBERInput = {
    US_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    US_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    US_MAIL?: NullableStringFieldUpdateOperationsInput | string | null
    US_PHONE?: NullableStringFieldUpdateOperationsInput | string | null
    US_BIRTH?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    US_GENDER?: NullableStringFieldUpdateOperationsInput | string | null
    US_ADDRESS?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_ACCESSIBILITYUpsertWithoutPROJECT_MEMBERInput = {
    update: XOR<PROJECT_ACCESSIBILITYUpdateWithoutPROJECT_MEMBERInput, PROJECT_ACCESSIBILITYUncheckedUpdateWithoutPROJECT_MEMBERInput>
    create: XOR<PROJECT_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, PROJECT_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_ACCESSIBILITYUpdateWithoutPROJECT_MEMBERInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    DEL_PJ?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM_POS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    CREATE_ANNOUNC_MNT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_ACCESSIBILITYUncheckedUpdateWithoutPROJECT_MEMBERInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    DEL_PJ?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM_POS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    CREATE_ANNOUNC_MNT?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TASK_ACCESSIBILITYUpsertWithoutPROJECT_MEMBERInput = {
    update: XOR<TASK_ACCESSIBILITYUpdateWithoutPROJECT_MEMBERInput, TASK_ACCESSIBILITYUncheckedUpdateWithoutPROJECT_MEMBERInput>
    create: XOR<TASK_ACCESSIBILITYCreateWithoutPROJECT_MEMBERInput, TASK_ACCESSIBILITYUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_ACCESSIBILITYUpdateWithoutPROJECT_MEMBERInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    ADD_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    DEL_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DEADLINE?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TASK_ACCESSIBILITYUncheckedUpdateWithoutPROJECT_MEMBERInput = {
    MEM_POS?: BigIntFieldUpdateOperationsInput | bigint | number
    EDIT_MEM?: NullableStringFieldUpdateOperationsInput | string | null
    ADD_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    DEL_TASK?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DEADLINE?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    EDIT_DESCRIPTION?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PROJECT_INFOUpsertWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    update: XOR<PROJECT_INFOUpdateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_INFOUncheckedUpdateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
    create: XOR<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput, PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput>
  }

  export type PROJECT_INFOUpdateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBERUpdateOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_INFONestedInput
  }

  export type PROJECT_INFOUncheckedUpdateWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_ADMIN?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_INFONestedInput
  }

  export type PROJECT_INFOUpsertWithWhereUniqueWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    where: PROJECT_INFOWhereUniqueInput
    update: XOR<PROJECT_INFOUpdateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_INFOUncheckedUpdateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
    create: XOR<PROJECT_INFOCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_INFOUncheckedCreateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOUpdateWithWhereUniqueWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    where: PROJECT_INFOWhereUniqueInput
    data: XOR<PROJECT_INFOUpdateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput, PROJECT_INFOUncheckedUpdateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOUpdateManyWithWhereWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    where: PROJECT_INFOScalarWhereInput
    data: XOR<PROJECT_INFOUpdateManyMutationInput, PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOScalarWhereInput = {
    AND?: Enumerable<PROJECT_INFOScalarWhereInput>
    OR?: Enumerable<PROJECT_INFOScalarWhereInput>
    NOT?: Enumerable<PROJECT_INFOScalarWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    PJ_NAME?: StringNullableFilter | string | null
    PJ_CREATEDAY?: DateTimeNullableFilter | Date | string | null
    PJ_DEADLINE?: DateTimeNullableFilter | Date | string | null
    PJ_STATUS?: StringNullableFilter | string | null
    PJ_ADMIN?: BigIntNullableFilter | bigint | number | null
    PJ_OWNER?: StringNullableFilter | string | null
  }

  export type TASK_INFOUpsertWithWhereUniqueWithoutPROJECT_MEMBERInput = {
    where: TASK_INFOWhereUniqueInput
    update: XOR<TASK_INFOUpdateWithoutPROJECT_MEMBERInput, TASK_INFOUncheckedUpdateWithoutPROJECT_MEMBERInput>
    create: XOR<TASK_INFOCreateWithoutPROJECT_MEMBERInput, TASK_INFOUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_INFOUpdateWithWhereUniqueWithoutPROJECT_MEMBERInput = {
    where: TASK_INFOWhereUniqueInput
    data: XOR<TASK_INFOUpdateWithoutPROJECT_MEMBERInput, TASK_INFOUncheckedUpdateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_INFOUpdateManyWithWhereWithoutPROJECT_MEMBERInput = {
    where: TASK_INFOScalarWhereInput
    data: XOR<TASK_INFOUpdateManyMutationInput, TASK_INFOUncheckedUpdateManyWithoutTASK_INFOInput>
  }

  export type TASK_RESPONDSIPLEUpsertWithWhereUniqueWithoutPROJECT_MEMBERInput = {
    where: TASK_RESPONDSIPLEWhereUniqueInput
    update: XOR<TASK_RESPONDSIPLEUpdateWithoutPROJECT_MEMBERInput, TASK_RESPONDSIPLEUncheckedUpdateWithoutPROJECT_MEMBERInput>
    create: XOR<TASK_RESPONDSIPLECreateWithoutPROJECT_MEMBERInput, TASK_RESPONDSIPLEUncheckedCreateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_RESPONDSIPLEUpdateWithWhereUniqueWithoutPROJECT_MEMBERInput = {
    where: TASK_RESPONDSIPLEWhereUniqueInput
    data: XOR<TASK_RESPONDSIPLEUpdateWithoutPROJECT_MEMBERInput, TASK_RESPONDSIPLEUncheckedUpdateWithoutPROJECT_MEMBERInput>
  }

  export type TASK_RESPONDSIPLEUpdateManyWithWhereWithoutPROJECT_MEMBERInput = {
    where: TASK_RESPONDSIPLEScalarWhereInput
    data: XOR<TASK_RESPONDSIPLEUpdateManyMutationInput, TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_RESPONDSIPLEInput>
  }

  export type TASK_RESPONDSIPLEScalarWhereInput = {
    AND?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
    OR?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
    NOT?: Enumerable<TASK_RESPONDSIPLEScalarWhereInput>
    PJ_ID?: BigIntFilter | bigint | number
    TASK_ID?: BigIntFilter | bigint | number
    MEM_ID?: BigIntFilter | bigint | number
  }

  export type PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutTASK_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput>
  }

  export type PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInputEnvelope = {
    data: Enumerable<PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInput>
    skipDuplicates?: boolean
  }

  export type PROJECT_MEMBERUpsertWithWhereUniqueWithoutTASK_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    update: XOR<PROJECT_MEMBERUpdateWithoutTASK_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedUpdateWithoutTASK_ACCESSIBILITYInput>
    create: XOR<PROJECT_MEMBERCreateWithoutTASK_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_ACCESSIBILITYInput>
  }

  export type PROJECT_MEMBERUpdateWithWhereUniqueWithoutTASK_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    data: XOR<PROJECT_MEMBERUpdateWithoutTASK_ACCESSIBILITYInput, PROJECT_MEMBERUncheckedUpdateWithoutTASK_ACCESSIBILITYInput>
  }

  export type PROJECT_MEMBERUpdateManyWithWhereWithoutTASK_ACCESSIBILITYInput = {
    where: PROJECT_MEMBERScalarWhereInput
    data: XOR<PROJECT_MEMBERUpdateManyMutationInput, PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_MEMBERInput>
  }

  export type PROJECT_INFOCreateWithoutTASK_INFOInput = {
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBERCreateNestedOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
  }

  export type PROJECT_INFOUncheckedCreateWithoutTASK_INFOInput = {
    PJ_ID: bigint | number
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_ADMIN?: bigint | number | null
    PJ_OWNER?: string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUncheckedCreateNestedManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
  }

  export type PROJECT_INFOCreateOrConnectWithoutTASK_INFOInput = {
    where: PROJECT_INFOWhereUniqueInput
    create: XOR<PROJECT_INFOCreateWithoutTASK_INFOInput, PROJECT_INFOUncheckedCreateWithoutTASK_INFOInput>
  }

  export type PROJECT_MEMBERCreateWithoutTASK_INFOInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLECreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutTASK_INFOInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutTASK_INFOInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutTASK_INFOInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_INFOInput>
  }

  export type TASK_RESPONDSIPLECreateWithoutTASK_INFOInput = {
    PROJECT_MEMBER: PROJECT_MEMBERCreateNestedOneWithoutTASK_RESPONDSIPLEInput
  }

  export type TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput = {
    MEM_ID: bigint | number
  }

  export type TASK_RESPONDSIPLECreateOrConnectWithoutTASK_INFOInput = {
    where: TASK_RESPONDSIPLEWhereUniqueInput
    create: XOR<TASK_RESPONDSIPLECreateWithoutTASK_INFOInput, TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput>
  }

  export type TASK_RESPONDSIPLECreateManyTASK_INFOInputEnvelope = {
    data: Enumerable<TASK_RESPONDSIPLECreateManyTASK_INFOInput>
    skipDuplicates?: boolean
  }

  export type PROJECT_INFOUpsertWithoutTASK_INFOInput = {
    update: XOR<PROJECT_INFOUpdateWithoutTASK_INFOInput, PROJECT_INFOUncheckedUpdateWithoutTASK_INFOInput>
    create: XOR<PROJECT_INFOCreateWithoutTASK_INFOInput, PROJECT_INFOUncheckedCreateWithoutTASK_INFOInput>
  }

  export type PROJECT_INFOUpdateWithoutTASK_INFOInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_MEMBERUpdateOneWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
  }

  export type PROJECT_INFOUncheckedUpdateWithoutTASK_INFOInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_ADMIN?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
  }

  export type PROJECT_MEMBERUpsertWithoutTASK_INFOInput = {
    update: XOR<PROJECT_MEMBERUpdateWithoutTASK_INFOInput, PROJECT_MEMBERUncheckedUpdateWithoutTASK_INFOInput>
    create: XOR<PROJECT_MEMBERCreateWithoutTASK_INFOInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_INFOInput>
  }

  export type PROJECT_MEMBERUpdateWithoutTASK_INFOInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutTASK_INFOInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type TASK_RESPONDSIPLEUpsertWithWhereUniqueWithoutTASK_INFOInput = {
    where: TASK_RESPONDSIPLEWhereUniqueInput
    update: XOR<TASK_RESPONDSIPLEUpdateWithoutTASK_INFOInput, TASK_RESPONDSIPLEUncheckedUpdateWithoutTASK_INFOInput>
    create: XOR<TASK_RESPONDSIPLECreateWithoutTASK_INFOInput, TASK_RESPONDSIPLEUncheckedCreateWithoutTASK_INFOInput>
  }

  export type TASK_RESPONDSIPLEUpdateWithWhereUniqueWithoutTASK_INFOInput = {
    where: TASK_RESPONDSIPLEWhereUniqueInput
    data: XOR<TASK_RESPONDSIPLEUpdateWithoutTASK_INFOInput, TASK_RESPONDSIPLEUncheckedUpdateWithoutTASK_INFOInput>
  }

  export type TASK_RESPONDSIPLEUpdateManyWithWhereWithoutTASK_INFOInput = {
    where: TASK_RESPONDSIPLEScalarWhereInput
    data: XOR<TASK_RESPONDSIPLEUpdateManyMutationInput, TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_RESPONDSIPLEInput>
  }

  export type PROJECT_MEMBERCreateWithoutTASK_RESPONDSIPLEInput = {
    USER_INFO: USER_INFOCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYCreateNestedOneWithoutPROJECT_MEMBERInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID: PROJECT_INFOCreateNestedOneWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERUncheckedCreateWithoutTASK_RESPONDSIPLEInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput
    TASK_INFO?: TASK_INFOUncheckedCreateNestedManyWithoutPROJECT_MEMBERInput
  }

  export type PROJECT_MEMBERCreateOrConnectWithoutTASK_RESPONDSIPLEInput = {
    where: PROJECT_MEMBERWhereUniqueInput
    create: XOR<PROJECT_MEMBERCreateWithoutTASK_RESPONDSIPLEInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
  }

  export type TASK_INFOCreateWithoutTASK_RESPONDSIPLEInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    PROJECT_INFO: PROJECT_INFOCreateNestedOneWithoutTASK_INFOInput
    PROJECT_MEMBER?: PROJECT_MEMBERCreateNestedOneWithoutTASK_INFOInput
  }

  export type TASK_INFOUncheckedCreateWithoutTASK_RESPONDSIPLEInput = {
    PJ_ID: bigint | number
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    TASK_CREATOR?: bigint | number | null
  }

  export type TASK_INFOCreateOrConnectWithoutTASK_RESPONDSIPLEInput = {
    where: TASK_INFOWhereUniqueInput
    create: XOR<TASK_INFOCreateWithoutTASK_RESPONDSIPLEInput, TASK_INFOUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
  }

  export type PROJECT_MEMBERUpsertWithoutTASK_RESPONDSIPLEInput = {
    update: XOR<PROJECT_MEMBERUpdateWithoutTASK_RESPONDSIPLEInput, PROJECT_MEMBERUncheckedUpdateWithoutTASK_RESPONDSIPLEInput>
    create: XOR<PROJECT_MEMBERCreateWithoutTASK_RESPONDSIPLEInput, PROJECT_MEMBERUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
  }

  export type PROJECT_MEMBERUpdateWithoutTASK_RESPONDSIPLEInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutTASK_RESPONDSIPLEInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type TASK_INFOUpsertWithoutTASK_RESPONDSIPLEInput = {
    update: XOR<TASK_INFOUpdateWithoutTASK_RESPONDSIPLEInput, TASK_INFOUncheckedUpdateWithoutTASK_RESPONDSIPLEInput>
    create: XOR<TASK_INFOCreateWithoutTASK_RESPONDSIPLEInput, TASK_INFOUncheckedCreateWithoutTASK_RESPONDSIPLEInput>
  }

  export type TASK_INFOUpdateWithoutTASK_RESPONDSIPLEInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PROJECT_INFO?: PROJECT_INFOUpdateOneRequiredWithoutTASK_INFONestedInput
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateOneWithoutTASK_INFONestedInput
  }

  export type TASK_INFOUncheckedUpdateWithoutTASK_RESPONDSIPLEInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_CREATOR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PROJECT_MEMBERCreateManyUSER_INFOInput = {
    PJ_ID: bigint | number
    MEM_POS?: bigint | number | null
  }

  export type PROJECT_MEMBERUpdateWithoutUSER_INFOInput = {
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutUSER_INFOInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_MEMBERInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PROJECT_MEMBERCreateManyPROJECT_ACCESSIBILITYInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
  }

  export type PROJECT_MEMBERUpdateWithoutPROJECT_ACCESSIBILITYInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_ACCESSIBILITYInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERCreateManyPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    MEM_ID: bigint | number
    MEM_POS?: bigint | number | null
  }

  export type TASK_INFOCreateManyPROJECT_INFOInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
    TASK_CREATOR?: bigint | number | null
  }

  export type PROJECT_MEMBERUpdateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    TASK_ACCESSIBILITY?: TASK_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDInput = {
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_POS?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type TASK_INFOUpdateWithoutPROJECT_INFOInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateOneWithoutTASK_INFONestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutTASK_INFONestedInput
  }

  export type TASK_INFOUncheckedUpdateWithoutPROJECT_INFOInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_CREATOR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_INFONestedInput
  }

  export type TASK_INFOUncheckedUpdateManyWithoutTASK_INFOInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_CREATOR?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PROJECT_INFOCreateManyPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_NAME?: string | null
    PJ_CREATEDAY?: Date | string | null
    PJ_DEADLINE?: Date | string | null
    PJ_STATUS?: string | null
    PJ_OWNER?: string | null
  }

  export type TASK_INFOCreateManyPROJECT_MEMBERInput = {
    TASK_ID: bigint | number
    TASK_STATUS?: string | null
    TASK_NAME?: string | null
    TASK_DESCRIPTON?: string | null
    TASK_CREATEDAY?: Date | string | null
    TASK_DEADLINE?: Date | string | null
  }

  export type TASK_RESPONDSIPLECreateManyPROJECT_MEMBERInput = {
    TASK_ID: bigint | number
  }

  export type PROJECT_INFOUpdateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_INFONestedInput
  }

  export type PROJECT_INFOUncheckedUpdateWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
    PROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_MEMBERUncheckedUpdateManyWithoutPROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_INFONestedInput
  }

  export type PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERInput = {
    PJ_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PJ_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    PJ_OWNER?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TASK_INFOUpdateWithoutPROJECT_MEMBERInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PROJECT_INFO?: PROJECT_INFOUpdateOneRequiredWithoutTASK_INFONestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutTASK_INFONestedInput
  }

  export type TASK_INFOUncheckedUpdateWithoutPROJECT_MEMBERInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    TASK_STATUS?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_NAME?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_DESCRIPTON?: NullableStringFieldUpdateOperationsInput | string | null
    TASK_CREATEDAY?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_DEADLINE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_INFONestedInput
  }

  export type TASK_RESPONDSIPLEUpdateWithoutPROJECT_MEMBERInput = {
    TASK_INFO?: TASK_INFOUpdateOneRequiredWithoutTASK_RESPONDSIPLENestedInput
  }

  export type TASK_RESPONDSIPLEUncheckedUpdateWithoutPROJECT_MEMBERInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TASK_RESPONDSIPLEUncheckedUpdateManyWithoutTASK_RESPONDSIPLEInput = {
    TASK_ID?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PROJECT_MEMBERCreateManyTASK_ACCESSIBILITYInput = {
    PJ_ID: bigint | number
    MEM_ID: bigint | number
  }

  export type PROJECT_MEMBERUpdateWithoutTASK_ACCESSIBILITYInput = {
    USER_INFO?: USER_INFOUpdateOneRequiredWithoutPROJECT_MEMBERNestedInput
    PROJECT_ACCESSIBILITY?: PROJECT_ACCESSIBILITYUpdateOneWithoutPROJECT_MEMBERNestedInput
    PROJECT_INFO_PROJECT_INFOToPROJECT_MEMBER_PJ_ID?: PROJECT_INFOUpdateOneRequiredWithoutPROJECT_MEMBER_PROJECT_INFOToPROJECT_MEMBER_PJ_IDNestedInput
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type PROJECT_MEMBERUncheckedUpdateWithoutTASK_ACCESSIBILITYInput = {
    PJ_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
    PROJECT_INFO_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBER?: PROJECT_INFOUncheckedUpdateManyWithoutPROJECT_MEMBER_PROJECT_INFO_PJ_ID_PJ_ADMINToPROJECT_MEMBERNestedInput
    TASK_INFO?: TASK_INFOUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
    TASK_RESPONDSIPLE?: TASK_RESPONDSIPLEUncheckedUpdateManyWithoutPROJECT_MEMBERNestedInput
  }

  export type TASK_RESPONDSIPLECreateManyTASK_INFOInput = {
    MEM_ID: bigint | number
  }

  export type TASK_RESPONDSIPLEUpdateWithoutTASK_INFOInput = {
    PROJECT_MEMBER?: PROJECT_MEMBERUpdateOneRequiredWithoutTASK_RESPONDSIPLENestedInput
  }

  export type TASK_RESPONDSIPLEUncheckedUpdateWithoutTASK_INFOInput = {
    MEM_ID?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}